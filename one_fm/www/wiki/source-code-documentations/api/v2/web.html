<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>api.v2.web API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>api.v2.web</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import base64
import grpc
from one_fm.proto import facial_recognition_pb2, facial_recognition_pb2_grpc, enroll_pb2, enroll_pb2_grpc
import frappe
from frappe import _
from frappe.utils import (
        now_datetime, cstr, nowdate, cint , getdate, get_first_day, get_last_day
)
import numpy as np
import datetime
from json import JSONEncoder
# import cv2, os
# import face_recognition
import json
# from imutils import face_utils, paths
from one_fm.api.doc_events import haversine
from one_fm.api.v2.roster import get_current_shift
from one_fm.api.v2.utils import response
from one_fm.api.v2.face_recognition import create_checkin_log



class NumpyArrayEncoder(JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.ndarray):
            return obj.tolist()
        return JSONEncoder.default(self, obj)

def setup_directories():
        &#34;&#34;&#34;
                Use this function to create directories needed for the face recognition system: dataset directory and facial embeddings
        &#34;&#34;&#34;
        from pathlib import Path
        Path(frappe.utils.cstr(frappe.local.site)+&#34;/private/files/user/&#34;).mkdir(parents=True, exist_ok=True)
        Path(frappe.utils.cstr(frappe.local.site)+&#34;/private/files/dataset/&#34;).mkdir(parents=True, exist_ok=True)
        Path(frappe.utils.cstr(frappe.local.site)+&#34;/private/files/facial_recognition/&#34;).mkdir(parents=True, exist_ok=True)
        Path(frappe.utils.cstr(frappe.local.site)+&#34;/private/files/face_rec_temp/&#34;).mkdir(parents=True, exist_ok=True)
        Path(frappe.utils.cstr(frappe.local.site)+&#34;/private/files/dataset/&#34;+frappe.session.user+&#34;/&#34;).mkdir(parents=True, exist_ok=True)

@frappe.whitelist()
def enroll():
        try:
                files = frappe.request.files
                file = files[&#39;file&#39;]
                
                # Get user video
                content_bytes = file.stream.read()
                content_base64_bytes = base64.b64encode(content_bytes)
                video_content = content_base64_bytes.decode(&#39;ascii&#39;)

                # Setup channel
                face_recognition_enroll_service_url = frappe.local.conf.face_recognition_enroll_service_url
                channel = grpc.secure_channel(face_recognition_enroll_service_url, grpc.ssl_channel_credentials())
                # setup stub
                stub = enroll_pb2_grpc.FaceRecognitionEnrollmentServiceStub(channel)
                        # request body
                req = enroll_pb2.EnrollRequest(
                        username = frappe.session.user,
                        user_encoded_video = video_content,
                )

                res = stub.FaceRecognitionEnroll(req)

                if res.enrollment == &#34;FAILED&#34;:
                        msg = res.message
                        data = res.data
                        frappe.throw(_(&#34;{msg}: {data}&#34;.format(msg=msg, data=data)))
                
                doc = frappe.get_doc(&#34;Employee&#34;, {&#34;user_id&#34;: frappe.session.user})
                doc.enrolled = 1
                doc.save(ignore_permissions=True)
                update_onboarding_employee(doc)
                frappe.db.commit()
                return _(&#34;Successfully Enrolled!&#34;)

        except Exception as exc:
                print(frappe.get_traceback())
                frappe.log_error(frappe.get_traceback())
                raise exc


@frappe.whitelist()
def verify():
    try:
        log_type = frappe.local.form_dict[&#39;log_type&#39;]
        skip_attendance = frappe.local.form_dict[&#39;skip_attendance&#39;]
        latitude = frappe.local.form_dict[&#39;latitude&#39;]
        longitude = frappe.local.form_dict[&#39;longitude&#39;]
        # timestamp = frappe.local.form_dict[&#39;timestamp&#39;]
        files = frappe.request.files
        file = files[&#39;file&#39;]

        employee = frappe.db.get_value(&#34;Employee&#34;, {&#39;user_id&#39;: frappe.session.user}, [&#34;name&#34;])

        # if not user_within_site_geofence(employee, log_type, latitude, longitude):
        #       frappe.throw(&#34;Please check {log_type} at your site location.&#34;.format(log_type=log_type))

        # Get user video
        content_bytes = file.stream.read()
        content_base64_bytes = base64.b64encode(content_bytes)
        video_content = content_base64_bytes.decode(&#39;ascii&#39;)

        # setup channel
        face_recognition_service_url = frappe.local.conf.face_recognition_service_url
        channel = grpc.secure_channel(face_recognition_service_url, grpc.ssl_channel_credentials())
        # setup stub
        stub = facial_recognition_pb2_grpc.FaceRecognitionServiceStub(channel)

        # request body
        req = facial_recognition_pb2.FaceRecognitionRequest(
            username = frappe.session.user,
            media_type = &#34;video&#34;,
            media_content = video_content,
        )
        # Call service stub and get response
        res = stub.FaceRecognition(req)

        if res.verification == &#34;FAILED&#34;:
            msg = res.message
            data = res.data
            #response(&#34;Bad Request&#34;, 400, None, _(&#34;{msg}: {data}&#34;.format(msg=msg, data=data)))
                # create_checkin_log()
        response(&#34;Success&#34;, 200, check_in(log_type, skip_attendance, latitude, longitude))        
    except Exception as exc:
        frappe.log_error(frappe.get_traceback())
        response(&#34;Error&#34;, 500, None, frappe.get_traceback())  

@frappe.whitelist()
def user_within_site_geofence(employee, log_type, user_latitude, user_longitude):
        &#34;&#34;&#34; This method checks if user&#39;s given coordinates fall within the geofence radius of the user&#39;s assigned site in Shift Assigment. &#34;&#34;&#34;
        shift = get_current_shift(employee)
        date = cstr(getdate())
        if shift:
                if frappe.db.exists(&#34;Shift Request&#34;, {&#34;employee&#34;:employee, &#39;from_date&#39;:[&#39;&lt;=&#39;,date],&#39;to_date&#39;:[&#39;&gt;=&#39;,date]}):
                        check_in_site, check_out_site = frappe.get_value(&#34;Shift Request&#34;, {&#34;employee&#34;:employee, &#39;from_date&#39;:[&#39;&lt;=&#39;,date],&#39;to_date&#39;:[&#39;&gt;=&#39;,date]},[&#34;check_in_site&#34;,&#34;check_out_site&#34;])
                        if log_type == &#34;IN&#34;:
                                location = frappe.get_list(&#34;Location&#34;, {&#39;name&#39;:check_in_site}, [&#34;latitude&#34;,&#34;longitude&#34;, &#34;geofence_radius&#34;])
                        else:
                                location = frappe.get_list(&#34;Location&#34;, {&#39;name&#39;:check_out_site}, [&#34;latitude&#34;,&#34;longitude&#34;, &#34;geofence_radius&#34;])                    
                
                else:
                        if shift.site_location:
                                location = frappe.get_list(&#34;Location&#34;, {&#39;name&#39;:shift.site_location}, [&#34;latitude&#34;,&#34;longitude&#34;, &#34;geofence_radius&#34;])
                        elif shift.shift:
                                site = frappe.get_value(&#34;Operations Shift&#34;, shift.shift, &#34;site&#34;)
                                location= frappe.db.sql(&#34;&#34;&#34;
                                        SELECT loc.latitude, loc.longitude, loc.geofence_radius
                                        FROM `tabLocation` as loc
                                        WHERE
                                        loc.name IN (SELECT site_location FROM `tabOperations Site` where name=&#34;{site}&#34;)
                                        &#34;&#34;&#34;.format(site=site), as_dict=1)

                if location:
                        location_details = location[0]
                        distance = float(haversine(location_details.latitude, location_details.longitude, user_latitude, user_longitude))
                        if distance &lt;= float(location_details.geofence_radius):
                                return True
        return False

def check_in(log_type, skip_attendance, latitude, longitude):
        try:
                employee = frappe.get_value(&#34;Employee&#34;, {&#34;user_id&#34;: frappe.session.user})
                checkin = frappe.new_doc(&#34;Employee Checkin&#34;)
                checkin.employee = employee
                checkin.log_type = log_type
                checkin.device_id = cstr(latitude)+&#34;,&#34;+cstr(longitude)
                checkin.skip_auto_attendance = cint(skip_attendance)
                # checkin.shift_assignment = get_current_shift(employee)
                # checkin.time = now_datetime()
                # checkin.actual_time = now_datetime()
                checkin.save()
                frappe.db.commit()
                return _(&#39;Check {log_type} successful! {docname}&#39;.format(log_type=log_type.lower(), docname=checkin.name))
        except:
                frappe.log_error(frappe.get_traceback(), &#39;Mobile Web Checkin&#39;)

@frappe.whitelist()
def forced_checkin(employee, log_type, time):
        checkin = frappe.new_doc(&#34;Employee Checkin&#34;)
        checkin.employee = employee
        checkin.log_type = log_type
        checkin.device_id = cstr(&#39;0&#39;)+&#34;,&#34;+cstr(&#39;0&#39;)
        checkin.skip_auto_attendance = cint(&#39;0&#39;)
        checkin.time = time
        checkin.actual_time = time
        # checkin.shift_assignment = get_current_shift(employee)
        checkin.save()
        frappe.db.commit()
        return _(&#39;Check {log_type} successful! {docname}&#39;.format(log_type=log_type.lower(), docname=checkin.name))

def update_onboarding_employee(employee):
    onboard_employee_exist = frappe.db.exists(&#39;Onboard Employee&#39;, {&#39;employee&#39;: employee.name})
    if onboard_employee_exist:
        onboard_employee = frappe.get_doc(&#39;Onboard Employee&#39;, onboard_employee_exist.name)
        onboard_employee.enrolled = True
        onboard_employee.enrolled_on = now_datetime()
        onboard_employee.save(ignore_permissions=True)
        frappe.db.commit()


def update_onboarding_employee(employee):
    onboard_employee_exist = frappe.db.exists(&#39;Onboard Employee&#39;, {&#39;employee&#39;: employee.name})
    if onboard_employee_exist:
        onboard_employee = frappe.get_doc(&#39;Onboard Employee&#39;, onboard_employee_exist)
        onboard_employee.enrolled = True
        onboard_employee.enrolled_on = now_datetime()
        onboard_employee.save(ignore_permissions=True)
        frappe.db.commit()

@frappe.whitelist()
def check_existing():
        &#34;&#34;&#34;API to determine the applicable Log type.
        The api checks employee&#39;s last lcheckin log type. and determine what next log type needs to be
        Returns:
                True: The log in was &#34;IN&#34;, so his next Log Type should be &#34;OUT&#34;.
                False: either no log type or last log type is &#34;OUT&#34;, so his next Ltg Type should be &#34;IN&#34;.
        &#34;&#34;&#34;
        employee = frappe.get_value(&#34;Employee&#34;, {&#34;user_id&#34;: frappe.session.user})

        # define logs
        logs = []
        
        # get current and previous day date.
        today = nowdate()
        prev_date = ((datetime.datetime.today() - datetime.timedelta(days=1)).strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)).split(&#34; &#34;)[0]

        #get Employee Schedule
        last_shift = frappe.get_list(&#34;Shift Assignment&#34;,fields=[&#34;*&#34;],filters={&#34;employee&#34;:employee},order_by=&#39;creation desc&#39;,limit_page_length=1)

        if not employee:
                frappe.throw(_(&#34;Please link an employee to the logged in user to proceed further.&#34;))

        shift = get_current_shift(employee)
        #if employee schedule is linked with the previous Checkin doc

        if shift and last_shift:
                start_date = (shift.start_date).strftime(&#34;%Y-%m-%d&#34;)
                if start_date == today or start_date == prev_date:
                        logs = frappe.db.sql(&#34;&#34;&#34;
                                select log_type from `tabEmployee Checkin` where skip_auto_attendance=0 and employee=&#34;{employee}&#34; and shift_assignment=&#34;{shift_assignment}&#34;
                                &#34;&#34;&#34;.format(employee=employee, shift_assignment=last_shift[0].name), as_dict=1)
        else:
                #get checkin log of today.
                logs = frappe.db.sql(&#34;&#34;&#34;
                        select log_type from `tabEmployee Checkin` where date(time)=date(&#34;{date}&#34;) and skip_auto_attendance=0 and employee=&#34;{employee}&#34;
                        &#34;&#34;&#34;.format(date=today, employee=employee), as_dict=1)
        val = [log.log_type for log in logs]

        #For Check IN
        if not val or (val and val[-1] == &#34;OUT&#34;):
                return False
        #For Check OUT
        else:
                return True


@frappe.whitelist()
def get_checkin_history(employee):

        &#34;&#34;&#34;
                RETRIEVE CHECKIN LOGS
        &#34;&#34;&#34;
        start = str(get_first_day(getdate()))
        end = str(get_last_day(getdate()))
        logs = frappe.db.sql(f&#34;&#34;&#34;
                SELECT name, log_type, time FROM `tabEmployee Checkin`
                WHERE employee=&#34;{employee}&#34; AND date BETWEEN &#39;{start}&#39; AND &#39;{end}&#39;
                ORDER BY time DESC
        &#34;&#34;&#34;, as_dict=1)
        response (&#34;success&#34;, 200, {&#39;logs&#39;:logs, &#39;start&#39;:start, &#39;end&#39;:end})</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="api.v2.web.check_existing"><code class="name flex">
<span>def <span class="ident">check_existing</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>API to determine the applicable Log type.
The api checks employee's last lcheckin log type. and determine what next log type needs to be</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code></dt>
<dd>The log in was "IN", so his next Log Type should be "OUT".</dd>
<dt><code>False</code></dt>
<dd>either no log type or last log type is "OUT", so his next Ltg Type should be "IN".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def check_existing():
        &#34;&#34;&#34;API to determine the applicable Log type.
        The api checks employee&#39;s last lcheckin log type. and determine what next log type needs to be
        Returns:
                True: The log in was &#34;IN&#34;, so his next Log Type should be &#34;OUT&#34;.
                False: either no log type or last log type is &#34;OUT&#34;, so his next Ltg Type should be &#34;IN&#34;.
        &#34;&#34;&#34;
        employee = frappe.get_value(&#34;Employee&#34;, {&#34;user_id&#34;: frappe.session.user})

        # define logs
        logs = []
        
        # get current and previous day date.
        today = nowdate()
        prev_date = ((datetime.datetime.today() - datetime.timedelta(days=1)).strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)).split(&#34; &#34;)[0]

        #get Employee Schedule
        last_shift = frappe.get_list(&#34;Shift Assignment&#34;,fields=[&#34;*&#34;],filters={&#34;employee&#34;:employee},order_by=&#39;creation desc&#39;,limit_page_length=1)

        if not employee:
                frappe.throw(_(&#34;Please link an employee to the logged in user to proceed further.&#34;))

        shift = get_current_shift(employee)
        #if employee schedule is linked with the previous Checkin doc

        if shift and last_shift:
                start_date = (shift.start_date).strftime(&#34;%Y-%m-%d&#34;)
                if start_date == today or start_date == prev_date:
                        logs = frappe.db.sql(&#34;&#34;&#34;
                                select log_type from `tabEmployee Checkin` where skip_auto_attendance=0 and employee=&#34;{employee}&#34; and shift_assignment=&#34;{shift_assignment}&#34;
                                &#34;&#34;&#34;.format(employee=employee, shift_assignment=last_shift[0].name), as_dict=1)
        else:
                #get checkin log of today.
                logs = frappe.db.sql(&#34;&#34;&#34;
                        select log_type from `tabEmployee Checkin` where date(time)=date(&#34;{date}&#34;) and skip_auto_attendance=0 and employee=&#34;{employee}&#34;
                        &#34;&#34;&#34;.format(date=today, employee=employee), as_dict=1)
        val = [log.log_type for log in logs]

        #For Check IN
        if not val or (val and val[-1] == &#34;OUT&#34;):
                return False
        #For Check OUT
        else:
                return True</code></pre>
</details>
</dd>
<dt id="api.v2.web.check_in"><code class="name flex">
<span>def <span class="ident">check_in</span></span>(<span>log_type, skip_attendance, latitude, longitude)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_in(log_type, skip_attendance, latitude, longitude):
        try:
                employee = frappe.get_value(&#34;Employee&#34;, {&#34;user_id&#34;: frappe.session.user})
                checkin = frappe.new_doc(&#34;Employee Checkin&#34;)
                checkin.employee = employee
                checkin.log_type = log_type
                checkin.device_id = cstr(latitude)+&#34;,&#34;+cstr(longitude)
                checkin.skip_auto_attendance = cint(skip_attendance)
                # checkin.shift_assignment = get_current_shift(employee)
                # checkin.time = now_datetime()
                # checkin.actual_time = now_datetime()
                checkin.save()
                frappe.db.commit()
                return _(&#39;Check {log_type} successful! {docname}&#39;.format(log_type=log_type.lower(), docname=checkin.name))
        except:
                frappe.log_error(frappe.get_traceback(), &#39;Mobile Web Checkin&#39;)</code></pre>
</details>
</dd>
<dt id="api.v2.web.enroll"><code class="name flex">
<span>def <span class="ident">enroll</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def enroll():
        try:
                files = frappe.request.files
                file = files[&#39;file&#39;]
                
                # Get user video
                content_bytes = file.stream.read()
                content_base64_bytes = base64.b64encode(content_bytes)
                video_content = content_base64_bytes.decode(&#39;ascii&#39;)

                # Setup channel
                face_recognition_enroll_service_url = frappe.local.conf.face_recognition_enroll_service_url
                channel = grpc.secure_channel(face_recognition_enroll_service_url, grpc.ssl_channel_credentials())
                # setup stub
                stub = enroll_pb2_grpc.FaceRecognitionEnrollmentServiceStub(channel)
                        # request body
                req = enroll_pb2.EnrollRequest(
                        username = frappe.session.user,
                        user_encoded_video = video_content,
                )

                res = stub.FaceRecognitionEnroll(req)

                if res.enrollment == &#34;FAILED&#34;:
                        msg = res.message
                        data = res.data
                        frappe.throw(_(&#34;{msg}: {data}&#34;.format(msg=msg, data=data)))
                
                doc = frappe.get_doc(&#34;Employee&#34;, {&#34;user_id&#34;: frappe.session.user})
                doc.enrolled = 1
                doc.save(ignore_permissions=True)
                update_onboarding_employee(doc)
                frappe.db.commit()
                return _(&#34;Successfully Enrolled!&#34;)

        except Exception as exc:
                print(frappe.get_traceback())
                frappe.log_error(frappe.get_traceback())
                raise exc</code></pre>
</details>
</dd>
<dt id="api.v2.web.forced_checkin"><code class="name flex">
<span>def <span class="ident">forced_checkin</span></span>(<span>employee, log_type, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def forced_checkin(employee, log_type, time):
        checkin = frappe.new_doc(&#34;Employee Checkin&#34;)
        checkin.employee = employee
        checkin.log_type = log_type
        checkin.device_id = cstr(&#39;0&#39;)+&#34;,&#34;+cstr(&#39;0&#39;)
        checkin.skip_auto_attendance = cint(&#39;0&#39;)
        checkin.time = time
        checkin.actual_time = time
        # checkin.shift_assignment = get_current_shift(employee)
        checkin.save()
        frappe.db.commit()
        return _(&#39;Check {log_type} successful! {docname}&#39;.format(log_type=log_type.lower(), docname=checkin.name))</code></pre>
</details>
</dd>
<dt id="api.v2.web.get_checkin_history"><code class="name flex">
<span>def <span class="ident">get_checkin_history</span></span>(<span>employee)</span>
</code></dt>
<dd>
<div class="desc"><p>RETRIEVE CHECKIN LOGS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def get_checkin_history(employee):

        &#34;&#34;&#34;
                RETRIEVE CHECKIN LOGS
        &#34;&#34;&#34;
        start = str(get_first_day(getdate()))
        end = str(get_last_day(getdate()))
        logs = frappe.db.sql(f&#34;&#34;&#34;
                SELECT name, log_type, time FROM `tabEmployee Checkin`
                WHERE employee=&#34;{employee}&#34; AND date BETWEEN &#39;{start}&#39; AND &#39;{end}&#39;
                ORDER BY time DESC
        &#34;&#34;&#34;, as_dict=1)
        response (&#34;success&#34;, 200, {&#39;logs&#39;:logs, &#39;start&#39;:start, &#39;end&#39;:end})</code></pre>
</details>
</dd>
<dt id="api.v2.web.setup_directories"><code class="name flex">
<span>def <span class="ident">setup_directories</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Use this function to create directories needed for the face recognition system: dataset directory and facial embeddings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_directories():
        &#34;&#34;&#34;
                Use this function to create directories needed for the face recognition system: dataset directory and facial embeddings
        &#34;&#34;&#34;
        from pathlib import Path
        Path(frappe.utils.cstr(frappe.local.site)+&#34;/private/files/user/&#34;).mkdir(parents=True, exist_ok=True)
        Path(frappe.utils.cstr(frappe.local.site)+&#34;/private/files/dataset/&#34;).mkdir(parents=True, exist_ok=True)
        Path(frappe.utils.cstr(frappe.local.site)+&#34;/private/files/facial_recognition/&#34;).mkdir(parents=True, exist_ok=True)
        Path(frappe.utils.cstr(frappe.local.site)+&#34;/private/files/face_rec_temp/&#34;).mkdir(parents=True, exist_ok=True)
        Path(frappe.utils.cstr(frappe.local.site)+&#34;/private/files/dataset/&#34;+frappe.session.user+&#34;/&#34;).mkdir(parents=True, exist_ok=True)</code></pre>
</details>
</dd>
<dt id="api.v2.web.update_onboarding_employee"><code class="name flex">
<span>def <span class="ident">update_onboarding_employee</span></span>(<span>employee)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_onboarding_employee(employee):
    onboard_employee_exist = frappe.db.exists(&#39;Onboard Employee&#39;, {&#39;employee&#39;: employee.name})
    if onboard_employee_exist:
        onboard_employee = frappe.get_doc(&#39;Onboard Employee&#39;, onboard_employee_exist)
        onboard_employee.enrolled = True
        onboard_employee.enrolled_on = now_datetime()
        onboard_employee.save(ignore_permissions=True)
        frappe.db.commit()</code></pre>
</details>
</dd>
<dt id="api.v2.web.user_within_site_geofence"><code class="name flex">
<span>def <span class="ident">user_within_site_geofence</span></span>(<span>employee, log_type, user_latitude, user_longitude)</span>
</code></dt>
<dd>
<div class="desc"><p>This method checks if user's given coordinates fall within the geofence radius of the user's assigned site in Shift Assigment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def user_within_site_geofence(employee, log_type, user_latitude, user_longitude):
        &#34;&#34;&#34; This method checks if user&#39;s given coordinates fall within the geofence radius of the user&#39;s assigned site in Shift Assigment. &#34;&#34;&#34;
        shift = get_current_shift(employee)
        date = cstr(getdate())
        if shift:
                if frappe.db.exists(&#34;Shift Request&#34;, {&#34;employee&#34;:employee, &#39;from_date&#39;:[&#39;&lt;=&#39;,date],&#39;to_date&#39;:[&#39;&gt;=&#39;,date]}):
                        check_in_site, check_out_site = frappe.get_value(&#34;Shift Request&#34;, {&#34;employee&#34;:employee, &#39;from_date&#39;:[&#39;&lt;=&#39;,date],&#39;to_date&#39;:[&#39;&gt;=&#39;,date]},[&#34;check_in_site&#34;,&#34;check_out_site&#34;])
                        if log_type == &#34;IN&#34;:
                                location = frappe.get_list(&#34;Location&#34;, {&#39;name&#39;:check_in_site}, [&#34;latitude&#34;,&#34;longitude&#34;, &#34;geofence_radius&#34;])
                        else:
                                location = frappe.get_list(&#34;Location&#34;, {&#39;name&#39;:check_out_site}, [&#34;latitude&#34;,&#34;longitude&#34;, &#34;geofence_radius&#34;])                    
                
                else:
                        if shift.site_location:
                                location = frappe.get_list(&#34;Location&#34;, {&#39;name&#39;:shift.site_location}, [&#34;latitude&#34;,&#34;longitude&#34;, &#34;geofence_radius&#34;])
                        elif shift.shift:
                                site = frappe.get_value(&#34;Operations Shift&#34;, shift.shift, &#34;site&#34;)
                                location= frappe.db.sql(&#34;&#34;&#34;
                                        SELECT loc.latitude, loc.longitude, loc.geofence_radius
                                        FROM `tabLocation` as loc
                                        WHERE
                                        loc.name IN (SELECT site_location FROM `tabOperations Site` where name=&#34;{site}&#34;)
                                        &#34;&#34;&#34;.format(site=site), as_dict=1)

                if location:
                        location_details = location[0]
                        distance = float(haversine(location_details.latitude, location_details.longitude, user_latitude, user_longitude))
                        if distance &lt;= float(location_details.geofence_radius):
                                return True
        return False</code></pre>
</details>
</dd>
<dt id="api.v2.web.verify"><code class="name flex">
<span>def <span class="ident">verify</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def verify():
    try:
        log_type = frappe.local.form_dict[&#39;log_type&#39;]
        skip_attendance = frappe.local.form_dict[&#39;skip_attendance&#39;]
        latitude = frappe.local.form_dict[&#39;latitude&#39;]
        longitude = frappe.local.form_dict[&#39;longitude&#39;]
        # timestamp = frappe.local.form_dict[&#39;timestamp&#39;]
        files = frappe.request.files
        file = files[&#39;file&#39;]

        employee = frappe.db.get_value(&#34;Employee&#34;, {&#39;user_id&#39;: frappe.session.user}, [&#34;name&#34;])

        # if not user_within_site_geofence(employee, log_type, latitude, longitude):
        #       frappe.throw(&#34;Please check {log_type} at your site location.&#34;.format(log_type=log_type))

        # Get user video
        content_bytes = file.stream.read()
        content_base64_bytes = base64.b64encode(content_bytes)
        video_content = content_base64_bytes.decode(&#39;ascii&#39;)

        # setup channel
        face_recognition_service_url = frappe.local.conf.face_recognition_service_url
        channel = grpc.secure_channel(face_recognition_service_url, grpc.ssl_channel_credentials())
        # setup stub
        stub = facial_recognition_pb2_grpc.FaceRecognitionServiceStub(channel)

        # request body
        req = facial_recognition_pb2.FaceRecognitionRequest(
            username = frappe.session.user,
            media_type = &#34;video&#34;,
            media_content = video_content,
        )
        # Call service stub and get response
        res = stub.FaceRecognition(req)

        if res.verification == &#34;FAILED&#34;:
            msg = res.message
            data = res.data
            #response(&#34;Bad Request&#34;, 400, None, _(&#34;{msg}: {data}&#34;.format(msg=msg, data=data)))
                # create_checkin_log()
        response(&#34;Success&#34;, 200, check_in(log_type, skip_attendance, latitude, longitude))        
    except Exception as exc:
        frappe.log_error(frappe.get_traceback())
        response(&#34;Error&#34;, 500, None, frappe.get_traceback())  </code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="api.v2.web.NumpyArrayEncoder"><code class="flex name class">
<span>class <span class="ident">NumpyArrayEncoder</span></span>
<span>(</span><span>*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Extensible JSON <a href="http://json.org">http://json.org</a> encoder for Python data structures.</p>
<p>Supports the following objects and types by default:</p>
<p>+-------------------+---------------+
| Python
| JSON
|
+===================+===============+
| dict
| object
|
+-------------------+---------------+
| list, tuple
| array
|
+-------------------+---------------+
| str
| string
|
+-------------------+---------------+
| int, float
| number
|
+-------------------+---------------+
| True
| true
|
+-------------------+---------------+
| False
| false
|
+-------------------+---------------+
| None
| null
|
+-------------------+---------------+</p>
<p>To extend this to recognize other objects, subclass and implement a
<code>.default()</code> method with another method that returns a serializable
object for <code>o</code> if possible, otherwise it should call the superclass
implementation (to raise <code>TypeError</code>).</p>
<p>Constructor for JSONEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, float or None.
If
skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming non-ASCII characters escaped.
If
ensure_ascii is false, the output can contain non-ASCII characters.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an RecursionError).
Otherwise, no such check takes place.</p>
<p>If allow_nan is true, then NaN, Infinity, and -Infinity will be
encoded as such.
This behavior is not JSON specification compliant,
but is consistent with most JavaScript based encoders and decoders.
Otherwise, it will be a ValueError to encode such floats.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a non-negative integer, then JSON array
elements and object members will be pretty-printed with that
indent level.
An indent level of 0 will only insert newlines.
None is the most compact representation.</p>
<p>If specified, separators should be an (item_separator, key_separator)
tuple.
The default is (', ', ': ') if <em>indent</em> is <code>None</code> and
(',', ': ') otherwise.
To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.
It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NumpyArrayEncoder(JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.ndarray):
            return obj.tolist()
        return JSONEncoder.default(self, obj)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>json.encoder.JSONEncoder</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="api.v2.web.NumpyArrayEncoder.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement this method in a subclass such that it returns
a serializable object for <code>o</code>, or calls the base implementation
(to raise a <code>TypeError</code>).</p>
<p>For example, to support arbitrary iterators, you could
implement default like this::</p>
<pre><code>def default(self, o):
    try:
        iterable = iter(o)
    except TypeError:
        pass
    else:
        return list(iterable)
    # Let the base class default method raise the TypeError
    return JSONEncoder.default(self, o)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default(self, obj):
    if isinstance(obj, np.ndarray):
        return obj.tolist()
    return JSONEncoder.default(self, obj)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="api.v2" href="index.html">api.v2</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="api.v2.web.check_existing" href="#api.v2.web.check_existing">check_existing</a></code></li>
<li><code><a title="api.v2.web.check_in" href="#api.v2.web.check_in">check_in</a></code></li>
<li><code><a title="api.v2.web.enroll" href="#api.v2.web.enroll">enroll</a></code></li>
<li><code><a title="api.v2.web.forced_checkin" href="#api.v2.web.forced_checkin">forced_checkin</a></code></li>
<li><code><a title="api.v2.web.get_checkin_history" href="#api.v2.web.get_checkin_history">get_checkin_history</a></code></li>
<li><code><a title="api.v2.web.setup_directories" href="#api.v2.web.setup_directories">setup_directories</a></code></li>
<li><code><a title="api.v2.web.update_onboarding_employee" href="#api.v2.web.update_onboarding_employee">update_onboarding_employee</a></code></li>
<li><code><a title="api.v2.web.user_within_site_geofence" href="#api.v2.web.user_within_site_geofence">user_within_site_geofence</a></code></li>
<li><code><a title="api.v2.web.verify" href="#api.v2.web.verify">verify</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="api.v2.web.NumpyArrayEncoder" href="#api.v2.web.NumpyArrayEncoder">NumpyArrayEncoder</a></code></h4>
<ul class="">
<li><code><a title="api.v2.web.NumpyArrayEncoder.default" href="#api.v2.web.NumpyArrayEncoder.default">default</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>