<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>api.doc_methods.payroll_entry API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>api.doc_methods.payroll_entry</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import frappe, erpnext, json
from dateutil.relativedelta import relativedelta
from frappe.utils import (
        cint, cstr, flt, nowdate, add_days, getdate, fmt_money, add_to_date, DATE_FORMAT, date_diff,
        get_first_day, get_last_day, get_link_to_form
)
from frappe import _
from frappe.utils.pdf import get_pdf
import openpyxl as xl
import time
import datetime
from datetime import datetime, timedelta
from copy import copy
from pathlib import Path
from hrms.payroll.doctype.payroll_entry.payroll_entry import (
        get_filter_condition, get_joining_relieving_condition, remove_payrolled_employees, get_sal_struct
)
from one_fm.one_fm.doctype.hr_and_payroll_additional_settings.hr_and_payroll_additional_settings import get_projects_not_configured_in_payroll_cycle_but_linked_in_employee

def validate_employee_attendance(self):
        employees_to_mark_attendance = []
        days_in_payroll, days_holiday, days_attendance_marked = 0, 0, 0

        for employee_detail in self.employees:
                days_holiday = self.get_count_holidays_of_employee(employee_detail.employee)
                days_attendance_marked, days_scheduled = self.get_count_employee_attendance(employee_detail.employee)

                days_in_payroll = date_diff(self.end_date, self.start_date) + 1
                if days_in_payroll != (days_holiday + days_attendance_marked) != (days_holiday + days_scheduled) :
                        employees_to_mark_attendance.append({
                                &#34;employee&#34;: employee_detail.employee,
                                &#34;employee_name&#34;: employee_detail.employee_name
                                })
        return employees_to_mark_attendance

def get_count_holidays_of_employee(self, employee):
        holidays = 0
        days = frappe.db.sql(&#34;&#34;&#34;select count(*) from `tabEmployee Schedule` where
                employee=%s and date between %s and %s and employee_availability in (&#34;Day Off&#34;, &#34;Sick Leave&#34;, &#34;Annual Leave&#34;, &#34;Emergency Leave&#34;) &#34;&#34;&#34;, (employee,
                self.start_date, self.end_date))
        if days and days[0][0]:
                holidays = days[0][0]
        return holidays

@frappe.whitelist()
def fill_employee_details(self, project_list=False):
        &#34;&#34;&#34;
        Method Override fill_employee_details in Payroll Entry
        This Function fetches the employee details and updates the &#39;Employee Details&#39; child table.

        Returns:
                list of active employees based on selected criteria
                and for which salary structure exists.
        &#34;&#34;&#34;
        self.set(&#39;employees&#39;, [])
        # Custom method to get employee list for one fm
        employees = get_emp_list(self, project_list)

        # Custom method to fetch Bank Details and update employee list
        set_bank_details(self, employees)

        if not employees:
                error_msg = _(&#34;No employees found for the mentioned criteria:&lt;br&gt;Company: {0}&lt;br&gt; Currency: {1}&lt;br&gt;Payroll Payable Account: {2}&#34;).format(
                        frappe.bold(self.company), frappe.bold(self.currency), frappe.bold(self.payroll_payable_account))
                if self.branch:
                        error_msg += &#34;&lt;br&gt;&#34; + _(&#34;Branch: {0}&#34;).format(frappe.bold(self.branch))
                if self.department:
                        error_msg += &#34;&lt;br&gt;&#34; + _(&#34;Department: {0}&#34;).format(frappe.bold(self.department))
                if self.designation:
                        error_msg += &#34;&lt;br&gt;&#34; + _(&#34;Designation: {0}&#34;).format(frappe.bold(self.designation))
                if self.start_date:
                        error_msg += &#34;&lt;br&gt;&#34; + _(&#34;Start date: {0}&#34;).format(frappe.bold(self.start_date))
                if self.end_date:
                        error_msg += &#34;&lt;br&gt;&#34; + _(&#34;End date: {0}&#34;).format(frappe.bold(self.end_date))
                frappe.throw(error_msg, title=_(&#34;No employees found&#34;))

        for d in employees:
                self.append(&#39;employees&#39;, d)
        self.number_of_employees = len(self.employees)
        if self.validate_attendance:
                return self.validate_employee_attendance()

@frappe.whitelist()
def get_emp_list(self, project_list=False):
        &#34;&#34;&#34;
                Returns list of active employees based on selected criteria
                and for which salary structure exists
        &#34;&#34;&#34;
        self.check_mandatory()
        filters = self.make_filters()
        cond = get_filter_condition(filters)
        cond += get_joining_relieving_condition(self.start_date, self.end_date)

        condition = &#34;&#34;
        if self.payroll_frequency:
                condition = &#34;&#34;&#34;and payroll_frequency = &#39;%(payroll_frequency)s&#39;&#34;&#34;&#34; % {
                        &#34;payroll_frequency&#34;: self.payroll_frequency
                }

        sal_struct = get_sal_struct(
                self.company, self.currency, self.salary_slip_based_on_timesheet, condition
        )
        if sal_struct:
                cond += &#34;and t2.salary_structure IN %(sal_struct)s &#34;
                cond += &#34;and t2.payroll_payable_account = %(payroll_payable_account)s &#34;
                cond += &#34;and %(from_date)s &gt;= t2.from_date &#34;
                if project_list:
                        cond += &#34;and t1.project IN ({0})&#34;.format(project_list)
                employee_list = get_employee_list(sal_struct, cond, self.end_date, self.payroll_payable_account)
                employee_list = remove_payrolled_employees(employee_list, self.start_date, self.end_date)
                return employee_list

@frappe.whitelist()
def get_employee_list(sal_struct, cond, end_date, payroll_payable_account):
        return frappe.db.sql(
                &#34;&#34;&#34;
                        select
                                distinct t1.name as employee, t1.employee_name, t1.department, t1.designation
                        from
                                `tabEmployee` t1, `tabSalary Structure Assignment` t2
                        where
                                t1.name = t2.employee
                                and t2.docstatus = 1
                                and t1.status = &#39;Active&#39;
                %s order by t2.from_date desc
                &#34;&#34;&#34;
                % cond,
                {
                        &#34;sal_struct&#34;: tuple(sal_struct),
                        &#34;from_date&#34;: end_date,
                        &#34;payroll_payable_account&#34;: payroll_payable_account
                },
                 as_dict=True,
        )

@frappe.whitelist()
def set_bank_details(self, employee_details):
        &#34;&#34;&#34;This Funtion Sets the bank Details of an employee. The data is fetched from Bank Account Doctype.

        Args:
                employee_details (dict): Employee Details Child Table.

        Returns:
                employee_details ([dict): Sets the bank account IBAN code and Bank Code.
        &#34;&#34;&#34;
        employee_missing_detail = []
        for employee in employee_details:
                try:
                        bank_account = frappe.db.get_value(&#34;Bank Account&#34;,{&#34;party&#34;:employee.employee},[&#34;iban&#34;,&#34;bank&#34;, &#34;bank_account_no&#34;])
                        salary_mode = frappe.db.get_value(&#34;Employee&#34;, {&#39;name&#39;: employee.employee}, [&#34;salary_mode&#34;])
                        if bank_account:
                                iban, bank, bank_account_no = bank_account
                        else:
                                iban, bank, bank_account_no = None, None, None

                        if not salary_mode:
                                employee_missing_detail.append(frappe._dict(
                                {&#39;employee&#39;:employee, &#39;salary_mode&#39;:&#39;&#39;, &#39;issue&#39;:&#39;No salary mode&#39;}))
                        elif(salary_mode==&#39;Bank&#39; and bank is None):
                                employee_missing_detail.append(frappe._dict(
                                        {&#39;employee&#39;:employee, &#39;salary_mode&#39;:salary_mode, &#39;issue&#39;:&#39;No bank account&#39;}))
                        elif(salary_mode==&#34;Bank&#34; and bank_account_no is None):
                                employee_missing_detail.append(frappe._dict(
                                        {&#39;employee&#39;:employee, &#39;salary_mode&#39;:salary_mode, &#39;issue&#39;:&#39;No account no.&#39;}))
                        employee.salary_mode = salary_mode
                        employee.iban_number = iban or bank_account_no
                        bank_code = frappe.db.get_value(&#34;Bank&#34;, {&#39;name&#39;: bank}, [&#34;bank_code&#34;])
                        employee.bank_code = bank_code
                except Exception as e:
                        frappe.log_error(str(e), &#39;Payroll Entry&#39;)
                        frappe.throw(str(e))

        # check for missing details, log and report
        if(len(employee_missing_detail)):
                missing_detail = [
                        {
                                &#39;employee&#39;:i.employee.employee,
                                &#39;salary_mode&#39;:i.salary_mode,
                                &#39;issue&#39;: i.issue
                        }
                        for i in employee_missing_detail]

                if(frappe.db.exists({
                        &#39;doctype&#39;:&#34;Missing Payroll Information&#34;,
                        &#39;payroll_entry&#39;: self.name
                        })):
                        fetch_mpi = frappe.db.sql(f&#34;&#34;&#34;
                                SELECT name FROM `tabMissing Payroll Information`
                                WHERE payroll_entry=&#34;{self.name}&#34;
                                ORDER BY modified DESC
                                LIMIT 1
                        ;&#34;&#34;&#34;, as_dict=1)
                        mpi = frappe.get_doc(&#39;Missing Payroll Information&#39;, fetch_mpi[0].name)
                        # delete previous table data
                        frappe.db.sql(f&#34;&#34;&#34;
                                DELETE FROM `tabMissing Payroll Information Detail`
                                WHERE parent=&#34;{mpi.name}&#34;
                        ;&#34;&#34;&#34;)
                        mpi.reload()
                        for i in missing_detail:
                                mpi.append(&#39;missing_payroll_information_detail&#39;, i)
                        mpi.save(ignore_permissions=True)
                        frappe.db.commit()
                else:
                        mpi = frappe.get_doc({
                                &#39;doctype&#39;:&#34;Missing Payroll Information&#34;,
                                &#39;payroll_entry&#39;: self.name,
                                &#39;missing_payroll_information_detail&#39;:missing_detail
                        }).insert(ignore_permissions=True)
                        frappe.db.commit()

                # generate html template to show to user screen
                message = frappe.render_template(
                        &#39;one_fm/api/doc_methods/templates/payroll/bank_issue.html&#39;,
                        context={&#39;employees&#39;:employee_missing_detail, &#39;mpi&#39;:mpi}
                )
                frappe.throw(_(message))
        return employee_details

def get_count_employee_attendance(self, employee):
        scheduled_days = 0
        marked_days = 0
        roster = frappe.db.sql(&#34;&#34;&#34;select count(*) from `tabEmployee Schedule` where
                employee=%s and date between %s and %s and employee_availability=&#34;Working&#34; &#34;&#34;&#34;,
                (employee, self.start_date, self.end_date))
        if roster and roster[0][0]:
                scheduled_days = roster[0][0]
        attendances = frappe.db.sql(&#34;&#34;&#34;select count(*) from tabAttendance where
                employee=%s and docstatus=1 and attendance_date between %s and %s&#34;&#34;&#34;,
                (employee, self.start_date, self.end_date))
        if attendances and attendances[0][0]:
                marked_days = attendances[0][0]
        return marked_days, scheduled_days

def auto_create_payroll_entry(payroll_date=None):
        &#34;&#34;&#34;
                Create Payroll Entry record with payroll cycle configured in HR and Payroll Additional Settings.
        &#34;&#34;&#34;
        # Get Payroll cycle list from HR and Payroll Settings and itrate for payroll cycle
        query = &#39;&#39;&#39;
                select
                        distinct payroll_start_day
                from
                        `tabProject Payroll Cycle`
        &#39;&#39;&#39;
        payroll_start_day_list = frappe.db.sql(query, as_dict=True)

        payroll_configured_projects = []

        if not payroll_date:
                payroll_date_day = frappe.db.get_single_value(&#39;HR and Payroll Additional Settings&#39;, &#39;payroll_date&#39;)
                # Calculate payroll date
                payroll_date = (datetime(getdate().year, getdate().month, cint(payroll_date_day))).strftime(&#34;%Y-%m-%d&#34;)

        for payroll_start_day in payroll_start_day_list:
                # Find from date and end date for payroll
                start_date, end_date = get_payroll_start_end_date_by_start_day(payroll_date, payroll_start_day.payroll_start_day)

                # Find projects comes under the same payroll cycle
                query = &#39;&#39;&#39;
                        select
                                project
                        from
                                `tabProject Payroll Cycle`
                        where
                                payroll_start_day = &#39;{0}&#39;
                &#39;&#39;&#39;
                projects = frappe.db.sql(query.format(payroll_start_day.payroll_start_day), as_dict=True)
                project_list = &#39;, &#39;.join([&#39;&#34;{}&#34;&#39;.format(project.project) for project in projects])
                payroll_configured_projects += projects
                # Create Payroll Entry
                create_monthly_payroll_entry(payroll_date, start_date, end_date, project_list)

        # Find default from date and end date for payroll
        default_payroll_start_day = frappe.db.get_single_value(&#39;HR and Payroll Additional Settings&#39;, &#39;default_payroll_start_day&#39;)
        default_start_date, default_end_date = get_payroll_start_end_date_by_start_day(payroll_date, default_payroll_start_day)

        # Fetch employee having project link but project not added in payroll configuration, then take default payroll cycle
        payroll_configured_project_list = &#39;, &#39;.join([&#39;&#34;{}&#34;&#39;.format(project.project) for project in payroll_configured_projects])
        projects_not_configured_in_payroll_cycle = get_projects_not_configured_in_payroll_cycle_but_linked_in_employee(payroll_configured_project_list)
        if projects_not_configured_in_payroll_cycle:
                project_list_not_configured_in_payroll_cycle = &#39;, &#39;.join([&#39;&#34;{}&#34;&#39;.format(project.project) for project in projects_not_configured_in_payroll_cycle])
                # Create Payroll Entry
                create_monthly_payroll_entry(payroll_date, default_start_date, default_end_date, project_list_not_configured_in_payroll_cycle)

        # TODO:
        # Fetch employee not having project link and set the payroll cycle as default
        # Create Payroll entry for the employees

def create_monthly_payroll_entry(payroll_date, start_date, end_date, project_list):
        try:
                payroll_entry = frappe.new_doc(&#34;Payroll Entry&#34;)
                payroll_entry.posting_date = getdate(payroll_date)
                payroll_entry.payroll_frequency = &#34;Monthly&#34;
                payroll_entry.exchange_rate = 0
                payroll_entry.payroll_payable_account = frappe.get_value(&#34;Company&#34;, erpnext.get_default_company(), &#34;default_payroll_payable_account&#34;)
                payroll_entry.company = erpnext.get_default_company()
                payroll_entry.start_date = start_date
                payroll_entry.end_date = end_date
                payroll_entry.cost_center = frappe.get_value(&#34;Company&#34;, erpnext.get_default_company(), &#34;cost_center&#34;)
                payroll_entry.save()
                # Fetch employees with the project filter
                payroll_entry.fill_employee_details(project_list)
                payroll_entry.save()
                payroll_entry.submit()
                frappe.db.commit()
        except Exception:
                frappe.log_error(frappe.get_traceback(), cstr(start_date)+&#39; | &#39;+cstr(end_date))

def get_payroll_start_end_date_by_start_day(payroll_date, start_day):
        if start_day == &#39;Month Start&#39;:
                start_day = 1
        if start_day == &#39;Month End&#39;:
                start_day = getdate(get_first_day(getdate(payroll_date))).day
        year = getdate(payroll_date).year - 1 if getdate(payroll_date).day &lt; cint(start_day) and  getdate(payroll_date).month == 1 else getdate(payroll_date).year
        month = getdate(payroll_date).month if getdate(payroll_date).day &gt;= cint(start_day) else getdate(payroll_date).month - 1
        date = datetime(year, month, cint(start_day)).strftime(&#34;%Y-%m-%d&#34;)
        if getdate(payroll_date) &lt;= getdate(date):
                start_date = add_to_date(date, months=-1)
                end_date = add_to_date(date, days=-1)
        else:
                start_date = getdate(date)
                end_date = add_to_date(date, days=-1, months=1)
        return start_date, end_date

def get_basic_salary(employee):
        filters = {
                &#39;docstatus&#39;: 1,
                &#39;employee&#39;: employee
        }
        salary_structure = frappe.get_value(&#34;Salary Structure Assignment&#34;, filters, &#34;salary_structure&#34;, order_by=&#34;from_date desc&#34;)
        if salary_structure:
                basic_salary = frappe.db.sql(&#34;&#34;&#34;
                        SELECT amount FROM `tabSalary Detail`
                        WHERE parenttype=&#34;Salary Structure&#34;
                        AND parent=%s
                        AND salary_component=&#34;Basic&#34;
                &#34;&#34;&#34;,(salary_structure), as_dict=1)

                return basic_salary[0].amount if len(basic_salary) &gt; 0 else 0.00
        else:
                frappe.throw(_(&#34;No Assigned Salary Structure found for the selected employee.&#34;))

@frappe.whitelist()
def export_payroll(doc, method):
        &#34;&#34;&#34; This method fetches the company bank details and makes a call to the export function based on the provided bank.

        Args:
                payroll_entry (document object): The payroll entry document object to set the export file field for.
        &#34;&#34;&#34;
        # Check if Export is enabled.
        if frappe.db.get_single_value(&#34;HR and Payroll Additional Settings&#34;, &#39;enable_export&#39;):
                # Get default bank used to pay salaries
                default_bank = frappe.db.get_single_value(&#34;HR and Payroll Additional Settings&#34;, &#39;default_bank&#39;)

                # Fetch template and bank code for default bank
                template_path, bank_code = frappe.db.get_value(&#34;Bank&#34;, {&#39;name&#39;: default_bank}, [&#34;payroll_export_template&#34;, &#34;bank_code&#34;])

                cash_salary_employees = []

                for employee in doc.employees:
                        if employee.salary_mode == &#34;Cash&#34;:
                                cash_salary_employees.append(employee)
                        elif employee.salary_mode == &#34;Bank&#34;:
                                if not employee.iban_number:
                                        frappe.throw(_(&#34;No Iban/Bank account set for employee: {employee}&#34;.format(employee=employee.employee)))
                        elif not employee.salary_mode:
                                frappe.throw(_(&#34;No salary mode set for employee: {employee}&#34;.format(employee=employee.employee)))

                if &#34;NBK&#34; in bank_code:
                        # Enqueue method for longer list of employees
                        if len(doc.employees) &gt; 30:
                                frappe.enqueue(export_nbk, doc=doc, template_path=template_path)
                        else:
                                export_nbk(doc, template_path)

                if len(cash_salary_employees) &gt; 0:
                        if len(cash_salary_employees) &gt; 30:
                                frappe.enqueue(export_cash_payroll, cash_salary_employees=cash_salary_employees, doc_name=doc.name)
                        else:
                                export_cash_payroll(cash_salary_employees, doc.name)
                else:
                        frappe.msgprint(_(&#34;No employees with salary mode as Cash.&#34;))


def export_nbk(doc, template_path):
        &#34;&#34;&#34;This method fetches the bank template from the provided directory, copies the template style and data into a new workbook, writes payroll entry data
                into the new workbook and saves it in the public files directory of the current site.

        Args:
                payroll_entry (document object): The payroll entry document object to be used for exporting the payroll data into the provided bank template and set the export file field.
                template_path (str): Path to the bank template file
        &#34;&#34;&#34;

        start = time.time()

        employees = doc.employees

        if len(employees) == 0:
                frappe.throw(_(&#34;No employees added to payroll entry.&#34;))

        if not doc.bank_account:
                frappe.throw(_(&#34;No bank account set in payroll entry.&#34;))

        iban, bank_account_no = frappe.db.get_value(&#34;Bank Account&#34;, {&#39;name&#39;: doc.bank_account}, [&#34;iban&#34;, &#34;bank_account_no&#34;])

        if not iban and not bank_account_no:
                frappe.throw(_(&#34;No IBAN or bank account number set for Bank Account: {bank_account}&#34;.format(bank_account=doc.bank_account)))

        try:
                # Load template file
                template_filename = cstr(frappe.local.site) + template_path
                template_wb = xl.load_workbook(filename=template_filename)
                template_ws = template_wb.worksheets[0]

                #-------------------- Copy template data to destination worksheet --------------------#
                # Setup new file
                destination_wb = xl.Workbook()
                destination_ws = destination_wb.active

                # Max row number with template data as per NBK template
                mr = 12
                # Max column number with template data as per NBK template
                mc = 7

                # copying the cell values from source excel file to destination excel file
                for i in range (1, mr + 1):
                        for j in range (1, mc + 1):
                                # reading cell value from source excel file
                                c = template_ws.cell(row = i, column = j)

                                d = destination_ws.cell(row = i, column = j)
                                # writing the read value to destination excel file
                                d.value = c.value
                                # Copy cell style
                                if c.has_style:
                                        d.font = copy(c.font)
                                        d.border = copy(c.border)
                                        d.fill = copy(c.fill)
                                        d.number_format = copy(c.number_format)
                                        d.protection = copy(c.protection)
                                        d.alignment = copy(c.alignment)
                #---------------------- End copy template data to destination worksheet ------------------#

                # Currency map as per NBK bank template
                currency_map = {
                        &#39;KWD&#39;: &#39;KWD - Kuwaiti Dinar&#39;,
                        &#39;USD&#39;: &#39;USD - US Dollar&#39;,
                        &#39;GBP&#39;: &#39;GBP - British Pound&#39;,
                        &#39;EUR&#39;: &#39;EUR - EURO&#39;,
                        &#39;CAD&#39;: &#39;CAD - Canadian Dollar&#39;,
                        &#39;AUD&#39;: &#39;AUD - Australian Dollar&#39;
                }

                # Set column numbers based on NBK bank template
                source_ws_emp_column_map = {
                        &#39;Employee Number&#39;: 1,
                        &#39;Employee Name&#39;: 2,
                        &#39;Employee IBAN Number&#39;: 3,
                        &#39;Payment Amount&#39;: 4,
                        &#39;Bank Code&#39;: 5,
                        &#39;Employee Civil ID&#39;: 6,
                        &#39;MOSAL ID&#39;: 7
                }

                # TODO: Fetch firm number
                currency = currency_map[doc.currency]
                posting_date = cstr(doc.posting_date).split(&#34;-&#34;) # =&gt; [yyyy, mm, dd]
                payment_month = posting_date[1] + &#34;-&#34; + posting_date[0] # =&gt; mm-yyyy

                # Set basic payroll details in row and columns based on NBK bank template
                destination_ws.cell(row=3, column=3).value = doc.company
                destination_ws.cell(row=4, column=3).value = bank_account_no or iban[-10:0]
                destination_ws.cell(row=5, column=3).value = doc.payment_purpose
                destination_ws.cell(row=6, column=3).value = payment_month
                destination_ws.cell(row=7, column=3).value = currency

                # Row number to start entering employee payroll data
                source_ws_employee_row_number = 13

                # Employee count for employee number column
                employee_number_column_count = 1

                total_hash = 0
                total_amount = 0

                # Set employee payroll details
                for employee in employees:
                        if employee.salary_mode == &#34;Bank&#34;:
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;Employee Number&#34;]).value = employee_number_column_count
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;Employee Name&#34;]).value = employee.employee_name
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;Employee IBAN Number&#34;]).value = employee.iban_number
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;Payment Amount&#34;]).value = employee.payment_amount
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;Bank Code&#34;]).value = employee.bank_code
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;Employee Civil ID&#34;]).value = employee.civil_id_number
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;MOSAL ID&#34;]).value = employee.mosal_id

                                iban_multipier = int(employee.iban_number[-10:])
                                total_hash += round(iban_multipier * employee.payment_amount, 3)
                                total_amount += round(employee.payment_amount, 3)

                                employee_number_column_count += 1
                                source_ws_employee_row_number += 1

                destination_ws.cell(row=8, column=3).value = len(employees)
                destination_ws.cell(row=9, column=3).value = total_amount
                destination_ws.cell(row=10, column=3).value = total_hash

                # Setup destination file directory with payroll entry name as filename
                Path(&#34;/home/frappe/frappe-bench/sites/{0}/public/files/payroll-entry/&#34;.format(frappe.local.site)).mkdir(parents=True, exist_ok=True)
                destination_file = cstr(frappe.local.site) + &#34;/public/files/payroll-entry/{payroll_entry}.xlsx&#34;.format(payroll_entry=doc.name)

                # Save updated template in same source directory
                destination_wb.save(filename=destination_file)

                end = time.time()

                # print(&#34;Total Execution Time: &#34;, end-start)

        except Exception as e:
                frappe.throw(e)


frappe.whitelist()
def export_cash_payroll(cash_salary_employees, doc_name):
        &#34;&#34;&#34;This method takes the list of employees who have salary mode set as Cash and exports the payroll employee details into an excel sheet.

        Args:
                cash_salary_employees (List[dict]): payroll empployee details
                doc_name (str): Name of the payroll entry document.
        &#34;&#34;&#34;
        try:
        # Setup destination file directory with payroll entry name as filename
                Path(&#34;/home/frappe/frappe-bench/sites/{0}/public/files/payroll-entry/&#34;.format(frappe.local.site)).mkdir(parents=True, exist_ok=True)
                destination_file = cstr(frappe.local.site) + &#34;/public/files/payroll-entry/Cash-{payroll_entry}.xlsx&#34;.format(payroll_entry=doc_name)
                destination_wb = xl.Workbook()
                destination_ws = destination_wb.active

                # Fill color in first row
                color_fill = xl.styles.PatternFill(start_color=&#39;FFFF00&#39;,
                   end_color=&#39;FFFF00&#39;,
                   fill_type=&#39;solid&#39;)
                i = 1
                while(i &lt; 5):
                        destination_ws.cell(row=1, column=i).fill = color_fill
                        i += 1

                # Set column names
                destination_ws.cell(row=1, column=1).value = &#34;Employee Name&#34;
                destination_ws.cell(row=1, column=2).value = &#34;Payment Amount&#34;
                destination_ws.cell(row=1, column=3).value = &#34;Civil ID&#34;
                destination_ws.cell(row=1, column=4).value = &#34;Mosal ID&#34;

                row_number = 2

                # Fill employees in rows
                for employee in cash_salary_employees:
                        destination_ws.cell(row=row_number, column=1).value = employee.employee_name
                        destination_ws.cell(row=row_number, column=2).value = employee.payment_amount
                        destination_ws.cell(row=row_number, column=3).value = employee.civil_id_number
                        destination_ws.cell(row=row_number, column=4).value = employee.mosal_id

                        row_number += 1

                destination_wb.save(filename=destination_file)

        except Exception as e:
                frappe.log_error(e)

@frappe.whitelist()
def email_missing_payment_information(recipients):
        &#34;&#34;&#34;
                Send missing salary payment information
                as an email.
        &#34;&#34;&#34;
        # print(frappe.session.data)
        # print(recipients, &#39;\n\n\n&#39;)

@frappe.whitelist()
def create_salary_slips(doc):
        &#34;&#34;&#34;
        Creates salary slip for selected employees if already not created
        &#34;&#34;&#34;
        doc.check_permission(&#34;write&#34;)
        employees = [emp.employee for emp in doc.employees]
        if employees:
                args = frappe._dict(
                        {
                                &#34;salary_slip_based_on_timesheet&#34;: doc.salary_slip_based_on_timesheet,
                                &#34;payroll_frequency&#34;: doc.payroll_frequency,
                                &#34;company&#34;: doc.company,
                                &#34;start_date&#34;: doc.start_date,
                                &#34;end_date&#34;: doc.end_date,
                                &#34;posting_date&#34;: doc.posting_date,
                                &#34;deduct_tax_for_unclaimed_employee_benefits&#34;: doc.deduct_tax_for_unclaimed_employee_benefits,
                                &#34;deduct_tax_for_unsubmitted_tax_exemption_proof&#34;: doc.deduct_tax_for_unsubmitted_tax_exemption_proof,
                                &#34;payroll_entry&#34;: doc.name,
                                &#34;exchange_rate&#34;: doc.exchange_rate,
                                &#34;currency&#34;: doc.currency,
                        }
                )

                if len(employees) &gt; 30 or frappe.flags.enqueue_payroll_entry:
                        doc.db_set(&#34;status&#34;, &#34;Queued&#34;)
                        frappe.enqueue(
                                create_salary_slips_for_employees,
                                employees=employees,
                                args=args,
                                publish_progress=False,
                                timeout=6000, 
                                queue=&#39;long&#39;
                        )
                        frappe.msgprint(
                                _(&#34;Salary Slip creation is queued. It may take a few minutes&#34;),
                                alert=True,
                                indicator=&#34;blue&#34;,
                        )
                else:
                        create_salary_slips_for_employees(employees, args, publish_progress=False)
                        # since this method is called via frm.call this doc needs to be updated manually
                        doc.reload()

def log_payroll_failure(process, payroll_entry, error):
        error_log = frappe.log_error(
                title=_(&#34;Salary Slip {0} failed for Payroll Entry {1}&#34;).format(process, payroll_entry.name)
        )
        message_log = frappe.message_log.pop() if frappe.message_log else str(error)

        try:
                error_message = json.loads(message_log).get(&#34;message&#34;)
        except Exception:
                error_message = message_log

        error_message += &#34;\n&#34; + _(&#34;Check Error Log {0} for more details.&#34;).format(
                get_link_to_form(&#34;Error Log&#34;, error_log.name)
        )

        payroll_entry.db_set({&#34;error_message&#34;: error_message, &#34;status&#34;: &#34;Failed&#34;})

def create_salary_slips_for_employees(employees, args, publish_progress=True ):
        try:
                payroll_entry = frappe.get_doc(&#34;Payroll Entry&#34;, args.payroll_entry)
                salary_slips_exist_for = get_existing_salary_slips(employees, args)
                count = 0
                start_date = args.start_date
                end_date = args.start_date

                args.pop(&#39;start_date&#39;)
                args.pop(&#39;end_date&#39;)
                salary_slip_chunk = []
                chunk_counter = 0

                employees_list = seperate_salary_slip(employees, start_date, end_date)
                if len(employees_list) &lt; 30:
                        for emp in employees_list:
                                if emp[&#39;employee&#39;] not in salary_slips_exist_for:
                                        args.update({&#34;doctype&#34;: &#34;Salary Slip&#34;})
                                        args.update(emp)
                                        
                                        frappe.get_doc(args).insert()
                                        count += 1
                                        if publish_progress:
                                                frappe.publish_progress(
                                                        count * 100 / len(set(employees) - set(salary_slips_exist_for)),
                                                        title=_(&#34;Creating Salary Slips...&#34;),
                                                )
                        
                else:
                        for emp in employees_list:
                                if emp[&#39;employee&#39;] not in salary_slips_exist_for:
                                        args.update({&#34;doctype&#34;: &#34;Salary Slip&#34;})
                                        args.update(emp)
                                        
                                        # salary_slip_list.append(frappe.get_doc(args))
                                        salary_slip_chunk.append(frappe.get_doc(args))
                                        chunk_counter += 1
                                        if len(salary_slip_chunk) &gt;= 30:
                                                frappe.enqueue(create_salary_slip_chunk,slips=salary_slip_chunk.copy())
                                                salary_slip_chunk = []
                                                chunk_counter=0

                                        # frappe.get_doc(args).insert()
                
                        if salary_slip_chunk:
                                frappe.enqueue(create_salary_slip_chunk,slips=salary_slip_chunk)
                
                
                payroll_entry.db_set({&#34;status&#34;: &#34;Submitted&#34;, &#34;salary_slips_created&#34;: 1, &#34;error_message&#34;: &#34;&#34;})

                if salary_slips_exist_for:
                        frappe.msgprint(
                                _(
                                        &#34;Salary Slips already exist for employees {}, and will not be processed by this payroll.&#34;
                                ).format(frappe.bold(&#34;, &#34;.join(emp for emp in salary_slips_exist_for))),
                                title=_(&#34;Message&#34;),
                                indicator=&#34;orange&#34;,
                        )

        except Exception as e:
                frappe.db.rollback()
                log_payroll_failure(&#34;creation&#34;, payroll_entry, e)

        finally:
                frappe.db.commit()  # nosemgrep
                frappe.publish_realtime(&#34;completed_salary_slip_creation&#34;)

def create_salary_slip_chunk(slips):
        for slip in slips:
                slip.insert()

def get_existing_salary_slips(employees, args):
        return frappe.db.sql_list(
                &#34;&#34;&#34;
                select distinct employee from `tabSalary Slip`
                where docstatus!= 2 and company = %s and payroll_entry = %s
                        and start_date &gt;= %s and end_date &lt;= %s
                        and employee in (%s)
        &#34;&#34;&#34;
                % (&#34;%s&#34;, &#34;%s&#34;, &#34;%s&#34;, &#34;%s&#34;, &#34;, &#34;.join([&#34;%s&#34;] * len(employees))),
                [args.company, args.payroll_entry, args.start_date, args.end_date] + employees,
        )

def seperate_salary_slip(employees, start_date, end_date):
        parm = []
        for emp in employees:
                salary_structure_assignment = frappe.get_all(&#34;Salary Structure Assignment&#34;, {&#34;employee&#34;:emp, &#34;from_date&#34;:[&#34;between&#34;,(start_date, end_date)]},[&#34;*&#34;])

                if len(salary_structure_assignment) &gt; 0:
                        mid_date = &#34;&#34;
                        for ssa in salary_structure_assignment:
                                start_date = datetime.strptime(start_date, &#39;%Y-%m-%d&#39;).date()
                                end_date = datetime.strptime(end_date, &#39;%Y-%m-%d&#39;).date()

                                if ssa.from_date &gt; start_date and ssa.from_date &lt; end_date:
                                        mid_date = ssa.from_date
                        if mid_date:
                                parm.append({&#34;employee&#34;: emp, &#34;start_date&#34;:start_date, &#34;end_date&#34;:mid_date - timedelta(days=1)})
                                parm.append({&#34;employee&#34;: emp, &#34;start_date&#34;:mid_date , &#34;end_date&#34;:end_date})
                else:
                        parm.append({&#34;employee&#34;: emp, &#34;start_date&#34;:start_date , &#34;end_date&#34;:end_date})
                
        return parm

                                

                                </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="api.doc_methods.payroll_entry.auto_create_payroll_entry"><code class="name flex">
<span>def <span class="ident">auto_create_payroll_entry</span></span>(<span>payroll_date=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create Payroll Entry record with payroll cycle configured in HR and Payroll Additional Settings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def auto_create_payroll_entry(payroll_date=None):
        &#34;&#34;&#34;
                Create Payroll Entry record with payroll cycle configured in HR and Payroll Additional Settings.
        &#34;&#34;&#34;
        # Get Payroll cycle list from HR and Payroll Settings and itrate for payroll cycle
        query = &#39;&#39;&#39;
                select
                        distinct payroll_start_day
                from
                        `tabProject Payroll Cycle`
        &#39;&#39;&#39;
        payroll_start_day_list = frappe.db.sql(query, as_dict=True)

        payroll_configured_projects = []

        if not payroll_date:
                payroll_date_day = frappe.db.get_single_value(&#39;HR and Payroll Additional Settings&#39;, &#39;payroll_date&#39;)
                # Calculate payroll date
                payroll_date = (datetime(getdate().year, getdate().month, cint(payroll_date_day))).strftime(&#34;%Y-%m-%d&#34;)

        for payroll_start_day in payroll_start_day_list:
                # Find from date and end date for payroll
                start_date, end_date = get_payroll_start_end_date_by_start_day(payroll_date, payroll_start_day.payroll_start_day)

                # Find projects comes under the same payroll cycle
                query = &#39;&#39;&#39;
                        select
                                project
                        from
                                `tabProject Payroll Cycle`
                        where
                                payroll_start_day = &#39;{0}&#39;
                &#39;&#39;&#39;
                projects = frappe.db.sql(query.format(payroll_start_day.payroll_start_day), as_dict=True)
                project_list = &#39;, &#39;.join([&#39;&#34;{}&#34;&#39;.format(project.project) for project in projects])
                payroll_configured_projects += projects
                # Create Payroll Entry
                create_monthly_payroll_entry(payroll_date, start_date, end_date, project_list)

        # Find default from date and end date for payroll
        default_payroll_start_day = frappe.db.get_single_value(&#39;HR and Payroll Additional Settings&#39;, &#39;default_payroll_start_day&#39;)
        default_start_date, default_end_date = get_payroll_start_end_date_by_start_day(payroll_date, default_payroll_start_day)

        # Fetch employee having project link but project not added in payroll configuration, then take default payroll cycle
        payroll_configured_project_list = &#39;, &#39;.join([&#39;&#34;{}&#34;&#39;.format(project.project) for project in payroll_configured_projects])
        projects_not_configured_in_payroll_cycle = get_projects_not_configured_in_payroll_cycle_but_linked_in_employee(payroll_configured_project_list)
        if projects_not_configured_in_payroll_cycle:
                project_list_not_configured_in_payroll_cycle = &#39;, &#39;.join([&#39;&#34;{}&#34;&#39;.format(project.project) for project in projects_not_configured_in_payroll_cycle])
                # Create Payroll Entry
                create_monthly_payroll_entry(payroll_date, default_start_date, default_end_date, project_list_not_configured_in_payroll_cycle)

        # TODO:
        # Fetch employee not having project link and set the payroll cycle as default
        # Create Payroll entry for the employees</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.create_monthly_payroll_entry"><code class="name flex">
<span>def <span class="ident">create_monthly_payroll_entry</span></span>(<span>payroll_date, start_date, end_date, project_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_monthly_payroll_entry(payroll_date, start_date, end_date, project_list):
        try:
                payroll_entry = frappe.new_doc(&#34;Payroll Entry&#34;)
                payroll_entry.posting_date = getdate(payroll_date)
                payroll_entry.payroll_frequency = &#34;Monthly&#34;
                payroll_entry.exchange_rate = 0
                payroll_entry.payroll_payable_account = frappe.get_value(&#34;Company&#34;, erpnext.get_default_company(), &#34;default_payroll_payable_account&#34;)
                payroll_entry.company = erpnext.get_default_company()
                payroll_entry.start_date = start_date
                payroll_entry.end_date = end_date
                payroll_entry.cost_center = frappe.get_value(&#34;Company&#34;, erpnext.get_default_company(), &#34;cost_center&#34;)
                payroll_entry.save()
                # Fetch employees with the project filter
                payroll_entry.fill_employee_details(project_list)
                payroll_entry.save()
                payroll_entry.submit()
                frappe.db.commit()
        except Exception:
                frappe.log_error(frappe.get_traceback(), cstr(start_date)+&#39; | &#39;+cstr(end_date))</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.create_salary_slip_chunk"><code class="name flex">
<span>def <span class="ident">create_salary_slip_chunk</span></span>(<span>slips)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_salary_slip_chunk(slips):
        for slip in slips:
                slip.insert()</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.create_salary_slips"><code class="name flex">
<span>def <span class="ident">create_salary_slips</span></span>(<span>doc)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates salary slip for selected employees if already not created</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def create_salary_slips(doc):
        &#34;&#34;&#34;
        Creates salary slip for selected employees if already not created
        &#34;&#34;&#34;
        doc.check_permission(&#34;write&#34;)
        employees = [emp.employee for emp in doc.employees]
        if employees:
                args = frappe._dict(
                        {
                                &#34;salary_slip_based_on_timesheet&#34;: doc.salary_slip_based_on_timesheet,
                                &#34;payroll_frequency&#34;: doc.payroll_frequency,
                                &#34;company&#34;: doc.company,
                                &#34;start_date&#34;: doc.start_date,
                                &#34;end_date&#34;: doc.end_date,
                                &#34;posting_date&#34;: doc.posting_date,
                                &#34;deduct_tax_for_unclaimed_employee_benefits&#34;: doc.deduct_tax_for_unclaimed_employee_benefits,
                                &#34;deduct_tax_for_unsubmitted_tax_exemption_proof&#34;: doc.deduct_tax_for_unsubmitted_tax_exemption_proof,
                                &#34;payroll_entry&#34;: doc.name,
                                &#34;exchange_rate&#34;: doc.exchange_rate,
                                &#34;currency&#34;: doc.currency,
                        }
                )

                if len(employees) &gt; 30 or frappe.flags.enqueue_payroll_entry:
                        doc.db_set(&#34;status&#34;, &#34;Queued&#34;)
                        frappe.enqueue(
                                create_salary_slips_for_employees,
                                employees=employees,
                                args=args,
                                publish_progress=False,
                                timeout=6000, 
                                queue=&#39;long&#39;
                        )
                        frappe.msgprint(
                                _(&#34;Salary Slip creation is queued. It may take a few minutes&#34;),
                                alert=True,
                                indicator=&#34;blue&#34;,
                        )
                else:
                        create_salary_slips_for_employees(employees, args, publish_progress=False)
                        # since this method is called via frm.call this doc needs to be updated manually
                        doc.reload()</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.create_salary_slips_for_employees"><code class="name flex">
<span>def <span class="ident">create_salary_slips_for_employees</span></span>(<span>employees, args, publish_progress=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_salary_slips_for_employees(employees, args, publish_progress=True ):
        try:
                payroll_entry = frappe.get_doc(&#34;Payroll Entry&#34;, args.payroll_entry)
                salary_slips_exist_for = get_existing_salary_slips(employees, args)
                count = 0
                start_date = args.start_date
                end_date = args.start_date

                args.pop(&#39;start_date&#39;)
                args.pop(&#39;end_date&#39;)
                salary_slip_chunk = []
                chunk_counter = 0

                employees_list = seperate_salary_slip(employees, start_date, end_date)
                if len(employees_list) &lt; 30:
                        for emp in employees_list:
                                if emp[&#39;employee&#39;] not in salary_slips_exist_for:
                                        args.update({&#34;doctype&#34;: &#34;Salary Slip&#34;})
                                        args.update(emp)
                                        
                                        frappe.get_doc(args).insert()
                                        count += 1
                                        if publish_progress:
                                                frappe.publish_progress(
                                                        count * 100 / len(set(employees) - set(salary_slips_exist_for)),
                                                        title=_(&#34;Creating Salary Slips...&#34;),
                                                )
                        
                else:
                        for emp in employees_list:
                                if emp[&#39;employee&#39;] not in salary_slips_exist_for:
                                        args.update({&#34;doctype&#34;: &#34;Salary Slip&#34;})
                                        args.update(emp)
                                        
                                        # salary_slip_list.append(frappe.get_doc(args))
                                        salary_slip_chunk.append(frappe.get_doc(args))
                                        chunk_counter += 1
                                        if len(salary_slip_chunk) &gt;= 30:
                                                frappe.enqueue(create_salary_slip_chunk,slips=salary_slip_chunk.copy())
                                                salary_slip_chunk = []
                                                chunk_counter=0

                                        # frappe.get_doc(args).insert()
                
                        if salary_slip_chunk:
                                frappe.enqueue(create_salary_slip_chunk,slips=salary_slip_chunk)
                
                
                payroll_entry.db_set({&#34;status&#34;: &#34;Submitted&#34;, &#34;salary_slips_created&#34;: 1, &#34;error_message&#34;: &#34;&#34;})

                if salary_slips_exist_for:
                        frappe.msgprint(
                                _(
                                        &#34;Salary Slips already exist for employees {}, and will not be processed by this payroll.&#34;
                                ).format(frappe.bold(&#34;, &#34;.join(emp for emp in salary_slips_exist_for))),
                                title=_(&#34;Message&#34;),
                                indicator=&#34;orange&#34;,
                        )

        except Exception as e:
                frappe.db.rollback()
                log_payroll_failure(&#34;creation&#34;, payroll_entry, e)

        finally:
                frappe.db.commit()  # nosemgrep
                frappe.publish_realtime(&#34;completed_salary_slip_creation&#34;)</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.email_missing_payment_information"><code class="name flex">
<span>def <span class="ident">email_missing_payment_information</span></span>(<span>recipients)</span>
</code></dt>
<dd>
<div class="desc"><p>Send missing salary payment information
as an email.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def email_missing_payment_information(recipients):
        &#34;&#34;&#34;
                Send missing salary payment information
                as an email.
        &#34;&#34;&#34;
        # print(frappe.session.data)
        # print(recipients, &#39;\n\n\n&#39;)</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.export_cash_payroll"><code class="name flex">
<span>def <span class="ident">export_cash_payroll</span></span>(<span>cash_salary_employees, doc_name)</span>
</code></dt>
<dd>
<div class="desc"><p>This method takes the list of employees who have salary mode set as Cash and exports the payroll employee details into an excel sheet.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cash_salary_employees</code></strong> :&ensp;<code>List[dict]</code></dt>
<dd>payroll empployee details</dd>
<dt><strong><code>doc_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the payroll entry document.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_cash_payroll(cash_salary_employees, doc_name):
        &#34;&#34;&#34;This method takes the list of employees who have salary mode set as Cash and exports the payroll employee details into an excel sheet.

        Args:
                cash_salary_employees (List[dict]): payroll empployee details
                doc_name (str): Name of the payroll entry document.
        &#34;&#34;&#34;
        try:
        # Setup destination file directory with payroll entry name as filename
                Path(&#34;/home/frappe/frappe-bench/sites/{0}/public/files/payroll-entry/&#34;.format(frappe.local.site)).mkdir(parents=True, exist_ok=True)
                destination_file = cstr(frappe.local.site) + &#34;/public/files/payroll-entry/Cash-{payroll_entry}.xlsx&#34;.format(payroll_entry=doc_name)
                destination_wb = xl.Workbook()
                destination_ws = destination_wb.active

                # Fill color in first row
                color_fill = xl.styles.PatternFill(start_color=&#39;FFFF00&#39;,
                   end_color=&#39;FFFF00&#39;,
                   fill_type=&#39;solid&#39;)
                i = 1
                while(i &lt; 5):
                        destination_ws.cell(row=1, column=i).fill = color_fill
                        i += 1

                # Set column names
                destination_ws.cell(row=1, column=1).value = &#34;Employee Name&#34;
                destination_ws.cell(row=1, column=2).value = &#34;Payment Amount&#34;
                destination_ws.cell(row=1, column=3).value = &#34;Civil ID&#34;
                destination_ws.cell(row=1, column=4).value = &#34;Mosal ID&#34;

                row_number = 2

                # Fill employees in rows
                for employee in cash_salary_employees:
                        destination_ws.cell(row=row_number, column=1).value = employee.employee_name
                        destination_ws.cell(row=row_number, column=2).value = employee.payment_amount
                        destination_ws.cell(row=row_number, column=3).value = employee.civil_id_number
                        destination_ws.cell(row=row_number, column=4).value = employee.mosal_id

                        row_number += 1

                destination_wb.save(filename=destination_file)

        except Exception as e:
                frappe.log_error(e)</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.export_nbk"><code class="name flex">
<span>def <span class="ident">export_nbk</span></span>(<span>doc, template_path)</span>
</code></dt>
<dd>
<div class="desc"><p>This method fetches the bank template from the provided directory, copies the template style and data into a new workbook, writes payroll entry data
into the new workbook and saves it in the public files directory of the current site.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>payroll_entry</code></strong> :&ensp;<code>document object</code></dt>
<dd>The payroll entry document object to be used for exporting the payroll data into the provided bank template and set the export file field.</dd>
<dt><strong><code>template_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the bank template file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_nbk(doc, template_path):
        &#34;&#34;&#34;This method fetches the bank template from the provided directory, copies the template style and data into a new workbook, writes payroll entry data
                into the new workbook and saves it in the public files directory of the current site.

        Args:
                payroll_entry (document object): The payroll entry document object to be used for exporting the payroll data into the provided bank template and set the export file field.
                template_path (str): Path to the bank template file
        &#34;&#34;&#34;

        start = time.time()

        employees = doc.employees

        if len(employees) == 0:
                frappe.throw(_(&#34;No employees added to payroll entry.&#34;))

        if not doc.bank_account:
                frappe.throw(_(&#34;No bank account set in payroll entry.&#34;))

        iban, bank_account_no = frappe.db.get_value(&#34;Bank Account&#34;, {&#39;name&#39;: doc.bank_account}, [&#34;iban&#34;, &#34;bank_account_no&#34;])

        if not iban and not bank_account_no:
                frappe.throw(_(&#34;No IBAN or bank account number set for Bank Account: {bank_account}&#34;.format(bank_account=doc.bank_account)))

        try:
                # Load template file
                template_filename = cstr(frappe.local.site) + template_path
                template_wb = xl.load_workbook(filename=template_filename)
                template_ws = template_wb.worksheets[0]

                #-------------------- Copy template data to destination worksheet --------------------#
                # Setup new file
                destination_wb = xl.Workbook()
                destination_ws = destination_wb.active

                # Max row number with template data as per NBK template
                mr = 12
                # Max column number with template data as per NBK template
                mc = 7

                # copying the cell values from source excel file to destination excel file
                for i in range (1, mr + 1):
                        for j in range (1, mc + 1):
                                # reading cell value from source excel file
                                c = template_ws.cell(row = i, column = j)

                                d = destination_ws.cell(row = i, column = j)
                                # writing the read value to destination excel file
                                d.value = c.value
                                # Copy cell style
                                if c.has_style:
                                        d.font = copy(c.font)
                                        d.border = copy(c.border)
                                        d.fill = copy(c.fill)
                                        d.number_format = copy(c.number_format)
                                        d.protection = copy(c.protection)
                                        d.alignment = copy(c.alignment)
                #---------------------- End copy template data to destination worksheet ------------------#

                # Currency map as per NBK bank template
                currency_map = {
                        &#39;KWD&#39;: &#39;KWD - Kuwaiti Dinar&#39;,
                        &#39;USD&#39;: &#39;USD - US Dollar&#39;,
                        &#39;GBP&#39;: &#39;GBP - British Pound&#39;,
                        &#39;EUR&#39;: &#39;EUR - EURO&#39;,
                        &#39;CAD&#39;: &#39;CAD - Canadian Dollar&#39;,
                        &#39;AUD&#39;: &#39;AUD - Australian Dollar&#39;
                }

                # Set column numbers based on NBK bank template
                source_ws_emp_column_map = {
                        &#39;Employee Number&#39;: 1,
                        &#39;Employee Name&#39;: 2,
                        &#39;Employee IBAN Number&#39;: 3,
                        &#39;Payment Amount&#39;: 4,
                        &#39;Bank Code&#39;: 5,
                        &#39;Employee Civil ID&#39;: 6,
                        &#39;MOSAL ID&#39;: 7
                }

                # TODO: Fetch firm number
                currency = currency_map[doc.currency]
                posting_date = cstr(doc.posting_date).split(&#34;-&#34;) # =&gt; [yyyy, mm, dd]
                payment_month = posting_date[1] + &#34;-&#34; + posting_date[0] # =&gt; mm-yyyy

                # Set basic payroll details in row and columns based on NBK bank template
                destination_ws.cell(row=3, column=3).value = doc.company
                destination_ws.cell(row=4, column=3).value = bank_account_no or iban[-10:0]
                destination_ws.cell(row=5, column=3).value = doc.payment_purpose
                destination_ws.cell(row=6, column=3).value = payment_month
                destination_ws.cell(row=7, column=3).value = currency

                # Row number to start entering employee payroll data
                source_ws_employee_row_number = 13

                # Employee count for employee number column
                employee_number_column_count = 1

                total_hash = 0
                total_amount = 0

                # Set employee payroll details
                for employee in employees:
                        if employee.salary_mode == &#34;Bank&#34;:
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;Employee Number&#34;]).value = employee_number_column_count
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;Employee Name&#34;]).value = employee.employee_name
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;Employee IBAN Number&#34;]).value = employee.iban_number
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;Payment Amount&#34;]).value = employee.payment_amount
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;Bank Code&#34;]).value = employee.bank_code
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;Employee Civil ID&#34;]).value = employee.civil_id_number
                                destination_ws.cell(row=source_ws_employee_row_number, column=source_ws_emp_column_map[&#34;MOSAL ID&#34;]).value = employee.mosal_id

                                iban_multipier = int(employee.iban_number[-10:])
                                total_hash += round(iban_multipier * employee.payment_amount, 3)
                                total_amount += round(employee.payment_amount, 3)

                                employee_number_column_count += 1
                                source_ws_employee_row_number += 1

                destination_ws.cell(row=8, column=3).value = len(employees)
                destination_ws.cell(row=9, column=3).value = total_amount
                destination_ws.cell(row=10, column=3).value = total_hash

                # Setup destination file directory with payroll entry name as filename
                Path(&#34;/home/frappe/frappe-bench/sites/{0}/public/files/payroll-entry/&#34;.format(frappe.local.site)).mkdir(parents=True, exist_ok=True)
                destination_file = cstr(frappe.local.site) + &#34;/public/files/payroll-entry/{payroll_entry}.xlsx&#34;.format(payroll_entry=doc.name)

                # Save updated template in same source directory
                destination_wb.save(filename=destination_file)

                end = time.time()

                # print(&#34;Total Execution Time: &#34;, end-start)

        except Exception as e:
                frappe.throw(e)</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.export_payroll"><code class="name flex">
<span>def <span class="ident">export_payroll</span></span>(<span>doc, method)</span>
</code></dt>
<dd>
<div class="desc"><p>This method fetches the company bank details and makes a call to the export function based on the provided bank.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>payroll_entry</code></strong> :&ensp;<code>document object</code></dt>
<dd>The payroll entry document object to set the export file field for.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def export_payroll(doc, method):
        &#34;&#34;&#34; This method fetches the company bank details and makes a call to the export function based on the provided bank.

        Args:
                payroll_entry (document object): The payroll entry document object to set the export file field for.
        &#34;&#34;&#34;
        # Check if Export is enabled.
        if frappe.db.get_single_value(&#34;HR and Payroll Additional Settings&#34;, &#39;enable_export&#39;):
                # Get default bank used to pay salaries
                default_bank = frappe.db.get_single_value(&#34;HR and Payroll Additional Settings&#34;, &#39;default_bank&#39;)

                # Fetch template and bank code for default bank
                template_path, bank_code = frappe.db.get_value(&#34;Bank&#34;, {&#39;name&#39;: default_bank}, [&#34;payroll_export_template&#34;, &#34;bank_code&#34;])

                cash_salary_employees = []

                for employee in doc.employees:
                        if employee.salary_mode == &#34;Cash&#34;:
                                cash_salary_employees.append(employee)
                        elif employee.salary_mode == &#34;Bank&#34;:
                                if not employee.iban_number:
                                        frappe.throw(_(&#34;No Iban/Bank account set for employee: {employee}&#34;.format(employee=employee.employee)))
                        elif not employee.salary_mode:
                                frappe.throw(_(&#34;No salary mode set for employee: {employee}&#34;.format(employee=employee.employee)))

                if &#34;NBK&#34; in bank_code:
                        # Enqueue method for longer list of employees
                        if len(doc.employees) &gt; 30:
                                frappe.enqueue(export_nbk, doc=doc, template_path=template_path)
                        else:
                                export_nbk(doc, template_path)

                if len(cash_salary_employees) &gt; 0:
                        if len(cash_salary_employees) &gt; 30:
                                frappe.enqueue(export_cash_payroll, cash_salary_employees=cash_salary_employees, doc_name=doc.name)
                        else:
                                export_cash_payroll(cash_salary_employees, doc.name)
                else:
                        frappe.msgprint(_(&#34;No employees with salary mode as Cash.&#34;))</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.fill_employee_details"><code class="name flex">
<span>def <span class="ident">fill_employee_details</span></span>(<span>self, project_list=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Method Override fill_employee_details in Payroll Entry
This Function fetches the employee details and updates the 'Employee Details' child table.</p>
<h2 id="returns">Returns</h2>
<p>list of active employees based on selected criteria
and for which salary structure exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def fill_employee_details(self, project_list=False):
        &#34;&#34;&#34;
        Method Override fill_employee_details in Payroll Entry
        This Function fetches the employee details and updates the &#39;Employee Details&#39; child table.

        Returns:
                list of active employees based on selected criteria
                and for which salary structure exists.
        &#34;&#34;&#34;
        self.set(&#39;employees&#39;, [])
        # Custom method to get employee list for one fm
        employees = get_emp_list(self, project_list)

        # Custom method to fetch Bank Details and update employee list
        set_bank_details(self, employees)

        if not employees:
                error_msg = _(&#34;No employees found for the mentioned criteria:&lt;br&gt;Company: {0}&lt;br&gt; Currency: {1}&lt;br&gt;Payroll Payable Account: {2}&#34;).format(
                        frappe.bold(self.company), frappe.bold(self.currency), frappe.bold(self.payroll_payable_account))
                if self.branch:
                        error_msg += &#34;&lt;br&gt;&#34; + _(&#34;Branch: {0}&#34;).format(frappe.bold(self.branch))
                if self.department:
                        error_msg += &#34;&lt;br&gt;&#34; + _(&#34;Department: {0}&#34;).format(frappe.bold(self.department))
                if self.designation:
                        error_msg += &#34;&lt;br&gt;&#34; + _(&#34;Designation: {0}&#34;).format(frappe.bold(self.designation))
                if self.start_date:
                        error_msg += &#34;&lt;br&gt;&#34; + _(&#34;Start date: {0}&#34;).format(frappe.bold(self.start_date))
                if self.end_date:
                        error_msg += &#34;&lt;br&gt;&#34; + _(&#34;End date: {0}&#34;).format(frappe.bold(self.end_date))
                frappe.throw(error_msg, title=_(&#34;No employees found&#34;))

        for d in employees:
                self.append(&#39;employees&#39;, d)
        self.number_of_employees = len(self.employees)
        if self.validate_attendance:
                return self.validate_employee_attendance()</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.get_basic_salary"><code class="name flex">
<span>def <span class="ident">get_basic_salary</span></span>(<span>employee)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_basic_salary(employee):
        filters = {
                &#39;docstatus&#39;: 1,
                &#39;employee&#39;: employee
        }
        salary_structure = frappe.get_value(&#34;Salary Structure Assignment&#34;, filters, &#34;salary_structure&#34;, order_by=&#34;from_date desc&#34;)
        if salary_structure:
                basic_salary = frappe.db.sql(&#34;&#34;&#34;
                        SELECT amount FROM `tabSalary Detail`
                        WHERE parenttype=&#34;Salary Structure&#34;
                        AND parent=%s
                        AND salary_component=&#34;Basic&#34;
                &#34;&#34;&#34;,(salary_structure), as_dict=1)

                return basic_salary[0].amount if len(basic_salary) &gt; 0 else 0.00
        else:
                frappe.throw(_(&#34;No Assigned Salary Structure found for the selected employee.&#34;))</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.get_count_employee_attendance"><code class="name flex">
<span>def <span class="ident">get_count_employee_attendance</span></span>(<span>self, employee)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_count_employee_attendance(self, employee):
        scheduled_days = 0
        marked_days = 0
        roster = frappe.db.sql(&#34;&#34;&#34;select count(*) from `tabEmployee Schedule` where
                employee=%s and date between %s and %s and employee_availability=&#34;Working&#34; &#34;&#34;&#34;,
                (employee, self.start_date, self.end_date))
        if roster and roster[0][0]:
                scheduled_days = roster[0][0]
        attendances = frappe.db.sql(&#34;&#34;&#34;select count(*) from tabAttendance where
                employee=%s and docstatus=1 and attendance_date between %s and %s&#34;&#34;&#34;,
                (employee, self.start_date, self.end_date))
        if attendances and attendances[0][0]:
                marked_days = attendances[0][0]
        return marked_days, scheduled_days</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.get_count_holidays_of_employee"><code class="name flex">
<span>def <span class="ident">get_count_holidays_of_employee</span></span>(<span>self, employee)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_count_holidays_of_employee(self, employee):
        holidays = 0
        days = frappe.db.sql(&#34;&#34;&#34;select count(*) from `tabEmployee Schedule` where
                employee=%s and date between %s and %s and employee_availability in (&#34;Day Off&#34;, &#34;Sick Leave&#34;, &#34;Annual Leave&#34;, &#34;Emergency Leave&#34;) &#34;&#34;&#34;, (employee,
                self.start_date, self.end_date))
        if days and days[0][0]:
                holidays = days[0][0]
        return holidays</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.get_emp_list"><code class="name flex">
<span>def <span class="ident">get_emp_list</span></span>(<span>self, project_list=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of active employees based on selected criteria
and for which salary structure exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def get_emp_list(self, project_list=False):
        &#34;&#34;&#34;
                Returns list of active employees based on selected criteria
                and for which salary structure exists
        &#34;&#34;&#34;
        self.check_mandatory()
        filters = self.make_filters()
        cond = get_filter_condition(filters)
        cond += get_joining_relieving_condition(self.start_date, self.end_date)

        condition = &#34;&#34;
        if self.payroll_frequency:
                condition = &#34;&#34;&#34;and payroll_frequency = &#39;%(payroll_frequency)s&#39;&#34;&#34;&#34; % {
                        &#34;payroll_frequency&#34;: self.payroll_frequency
                }

        sal_struct = get_sal_struct(
                self.company, self.currency, self.salary_slip_based_on_timesheet, condition
        )
        if sal_struct:
                cond += &#34;and t2.salary_structure IN %(sal_struct)s &#34;
                cond += &#34;and t2.payroll_payable_account = %(payroll_payable_account)s &#34;
                cond += &#34;and %(from_date)s &gt;= t2.from_date &#34;
                if project_list:
                        cond += &#34;and t1.project IN ({0})&#34;.format(project_list)
                employee_list = get_employee_list(sal_struct, cond, self.end_date, self.payroll_payable_account)
                employee_list = remove_payrolled_employees(employee_list, self.start_date, self.end_date)
                return employee_list</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.get_employee_list"><code class="name flex">
<span>def <span class="ident">get_employee_list</span></span>(<span>sal_struct, cond, end_date, payroll_payable_account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def get_employee_list(sal_struct, cond, end_date, payroll_payable_account):
        return frappe.db.sql(
                &#34;&#34;&#34;
                        select
                                distinct t1.name as employee, t1.employee_name, t1.department, t1.designation
                        from
                                `tabEmployee` t1, `tabSalary Structure Assignment` t2
                        where
                                t1.name = t2.employee
                                and t2.docstatus = 1
                                and t1.status = &#39;Active&#39;
                %s order by t2.from_date desc
                &#34;&#34;&#34;
                % cond,
                {
                        &#34;sal_struct&#34;: tuple(sal_struct),
                        &#34;from_date&#34;: end_date,
                        &#34;payroll_payable_account&#34;: payroll_payable_account
                },
                 as_dict=True,
        )</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.get_existing_salary_slips"><code class="name flex">
<span>def <span class="ident">get_existing_salary_slips</span></span>(<span>employees, args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_existing_salary_slips(employees, args):
        return frappe.db.sql_list(
                &#34;&#34;&#34;
                select distinct employee from `tabSalary Slip`
                where docstatus!= 2 and company = %s and payroll_entry = %s
                        and start_date &gt;= %s and end_date &lt;= %s
                        and employee in (%s)
        &#34;&#34;&#34;
                % (&#34;%s&#34;, &#34;%s&#34;, &#34;%s&#34;, &#34;%s&#34;, &#34;, &#34;.join([&#34;%s&#34;] * len(employees))),
                [args.company, args.payroll_entry, args.start_date, args.end_date] + employees,
        )</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.get_payroll_start_end_date_by_start_day"><code class="name flex">
<span>def <span class="ident">get_payroll_start_end_date_by_start_day</span></span>(<span>payroll_date, start_day)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_payroll_start_end_date_by_start_day(payroll_date, start_day):
        if start_day == &#39;Month Start&#39;:
                start_day = 1
        if start_day == &#39;Month End&#39;:
                start_day = getdate(get_first_day(getdate(payroll_date))).day
        year = getdate(payroll_date).year - 1 if getdate(payroll_date).day &lt; cint(start_day) and  getdate(payroll_date).month == 1 else getdate(payroll_date).year
        month = getdate(payroll_date).month if getdate(payroll_date).day &gt;= cint(start_day) else getdate(payroll_date).month - 1
        date = datetime(year, month, cint(start_day)).strftime(&#34;%Y-%m-%d&#34;)
        if getdate(payroll_date) &lt;= getdate(date):
                start_date = add_to_date(date, months=-1)
                end_date = add_to_date(date, days=-1)
        else:
                start_date = getdate(date)
                end_date = add_to_date(date, days=-1, months=1)
        return start_date, end_date</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.log_payroll_failure"><code class="name flex">
<span>def <span class="ident">log_payroll_failure</span></span>(<span>process, payroll_entry, error)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_payroll_failure(process, payroll_entry, error):
        error_log = frappe.log_error(
                title=_(&#34;Salary Slip {0} failed for Payroll Entry {1}&#34;).format(process, payroll_entry.name)
        )
        message_log = frappe.message_log.pop() if frappe.message_log else str(error)

        try:
                error_message = json.loads(message_log).get(&#34;message&#34;)
        except Exception:
                error_message = message_log

        error_message += &#34;\n&#34; + _(&#34;Check Error Log {0} for more details.&#34;).format(
                get_link_to_form(&#34;Error Log&#34;, error_log.name)
        )

        payroll_entry.db_set({&#34;error_message&#34;: error_message, &#34;status&#34;: &#34;Failed&#34;})</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.seperate_salary_slip"><code class="name flex">
<span>def <span class="ident">seperate_salary_slip</span></span>(<span>employees, start_date, end_date)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seperate_salary_slip(employees, start_date, end_date):
        parm = []
        for emp in employees:
                salary_structure_assignment = frappe.get_all(&#34;Salary Structure Assignment&#34;, {&#34;employee&#34;:emp, &#34;from_date&#34;:[&#34;between&#34;,(start_date, end_date)]},[&#34;*&#34;])

                if len(salary_structure_assignment) &gt; 0:
                        mid_date = &#34;&#34;
                        for ssa in salary_structure_assignment:
                                start_date = datetime.strptime(start_date, &#39;%Y-%m-%d&#39;).date()
                                end_date = datetime.strptime(end_date, &#39;%Y-%m-%d&#39;).date()

                                if ssa.from_date &gt; start_date and ssa.from_date &lt; end_date:
                                        mid_date = ssa.from_date
                        if mid_date:
                                parm.append({&#34;employee&#34;: emp, &#34;start_date&#34;:start_date, &#34;end_date&#34;:mid_date - timedelta(days=1)})
                                parm.append({&#34;employee&#34;: emp, &#34;start_date&#34;:mid_date , &#34;end_date&#34;:end_date})
                else:
                        parm.append({&#34;employee&#34;: emp, &#34;start_date&#34;:start_date , &#34;end_date&#34;:end_date})
                
        return parm</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.set_bank_details"><code class="name flex">
<span>def <span class="ident">set_bank_details</span></span>(<span>self, employee_details)</span>
</code></dt>
<dd>
<div class="desc"><p>This Funtion Sets the bank Details of an employee. The data is fetched from Bank Account Doctype.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>employee_details</code></strong> :&ensp;<code>dict</code></dt>
<dd>Employee Details Child Table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>employee_details ([dict): Sets the bank account IBAN code and Bank Code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@frappe.whitelist()
def set_bank_details(self, employee_details):
        &#34;&#34;&#34;This Funtion Sets the bank Details of an employee. The data is fetched from Bank Account Doctype.

        Args:
                employee_details (dict): Employee Details Child Table.

        Returns:
                employee_details ([dict): Sets the bank account IBAN code and Bank Code.
        &#34;&#34;&#34;
        employee_missing_detail = []
        for employee in employee_details:
                try:
                        bank_account = frappe.db.get_value(&#34;Bank Account&#34;,{&#34;party&#34;:employee.employee},[&#34;iban&#34;,&#34;bank&#34;, &#34;bank_account_no&#34;])
                        salary_mode = frappe.db.get_value(&#34;Employee&#34;, {&#39;name&#39;: employee.employee}, [&#34;salary_mode&#34;])
                        if bank_account:
                                iban, bank, bank_account_no = bank_account
                        else:
                                iban, bank, bank_account_no = None, None, None

                        if not salary_mode:
                                employee_missing_detail.append(frappe._dict(
                                {&#39;employee&#39;:employee, &#39;salary_mode&#39;:&#39;&#39;, &#39;issue&#39;:&#39;No salary mode&#39;}))
                        elif(salary_mode==&#39;Bank&#39; and bank is None):
                                employee_missing_detail.append(frappe._dict(
                                        {&#39;employee&#39;:employee, &#39;salary_mode&#39;:salary_mode, &#39;issue&#39;:&#39;No bank account&#39;}))
                        elif(salary_mode==&#34;Bank&#34; and bank_account_no is None):
                                employee_missing_detail.append(frappe._dict(
                                        {&#39;employee&#39;:employee, &#39;salary_mode&#39;:salary_mode, &#39;issue&#39;:&#39;No account no.&#39;}))
                        employee.salary_mode = salary_mode
                        employee.iban_number = iban or bank_account_no
                        bank_code = frappe.db.get_value(&#34;Bank&#34;, {&#39;name&#39;: bank}, [&#34;bank_code&#34;])
                        employee.bank_code = bank_code
                except Exception as e:
                        frappe.log_error(str(e), &#39;Payroll Entry&#39;)
                        frappe.throw(str(e))

        # check for missing details, log and report
        if(len(employee_missing_detail)):
                missing_detail = [
                        {
                                &#39;employee&#39;:i.employee.employee,
                                &#39;salary_mode&#39;:i.salary_mode,
                                &#39;issue&#39;: i.issue
                        }
                        for i in employee_missing_detail]

                if(frappe.db.exists({
                        &#39;doctype&#39;:&#34;Missing Payroll Information&#34;,
                        &#39;payroll_entry&#39;: self.name
                        })):
                        fetch_mpi = frappe.db.sql(f&#34;&#34;&#34;
                                SELECT name FROM `tabMissing Payroll Information`
                                WHERE payroll_entry=&#34;{self.name}&#34;
                                ORDER BY modified DESC
                                LIMIT 1
                        ;&#34;&#34;&#34;, as_dict=1)
                        mpi = frappe.get_doc(&#39;Missing Payroll Information&#39;, fetch_mpi[0].name)
                        # delete previous table data
                        frappe.db.sql(f&#34;&#34;&#34;
                                DELETE FROM `tabMissing Payroll Information Detail`
                                WHERE parent=&#34;{mpi.name}&#34;
                        ;&#34;&#34;&#34;)
                        mpi.reload()
                        for i in missing_detail:
                                mpi.append(&#39;missing_payroll_information_detail&#39;, i)
                        mpi.save(ignore_permissions=True)
                        frappe.db.commit()
                else:
                        mpi = frappe.get_doc({
                                &#39;doctype&#39;:&#34;Missing Payroll Information&#34;,
                                &#39;payroll_entry&#39;: self.name,
                                &#39;missing_payroll_information_detail&#39;:missing_detail
                        }).insert(ignore_permissions=True)
                        frappe.db.commit()

                # generate html template to show to user screen
                message = frappe.render_template(
                        &#39;one_fm/api/doc_methods/templates/payroll/bank_issue.html&#39;,
                        context={&#39;employees&#39;:employee_missing_detail, &#39;mpi&#39;:mpi}
                )
                frappe.throw(_(message))
        return employee_details</code></pre>
</details>
</dd>
<dt id="api.doc_methods.payroll_entry.validate_employee_attendance"><code class="name flex">
<span>def <span class="ident">validate_employee_attendance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_employee_attendance(self):
        employees_to_mark_attendance = []
        days_in_payroll, days_holiday, days_attendance_marked = 0, 0, 0

        for employee_detail in self.employees:
                days_holiday = self.get_count_holidays_of_employee(employee_detail.employee)
                days_attendance_marked, days_scheduled = self.get_count_employee_attendance(employee_detail.employee)

                days_in_payroll = date_diff(self.end_date, self.start_date) + 1
                if days_in_payroll != (days_holiday + days_attendance_marked) != (days_holiday + days_scheduled) :
                        employees_to_mark_attendance.append({
                                &#34;employee&#34;: employee_detail.employee,
                                &#34;employee_name&#34;: employee_detail.employee_name
                                })
        return employees_to_mark_attendance</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="api.doc_methods" href="index.html">api.doc_methods</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="api.doc_methods.payroll_entry.auto_create_payroll_entry" href="#api.doc_methods.payroll_entry.auto_create_payroll_entry">auto_create_payroll_entry</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.create_monthly_payroll_entry" href="#api.doc_methods.payroll_entry.create_monthly_payroll_entry">create_monthly_payroll_entry</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.create_salary_slip_chunk" href="#api.doc_methods.payroll_entry.create_salary_slip_chunk">create_salary_slip_chunk</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.create_salary_slips" href="#api.doc_methods.payroll_entry.create_salary_slips">create_salary_slips</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.create_salary_slips_for_employees" href="#api.doc_methods.payroll_entry.create_salary_slips_for_employees">create_salary_slips_for_employees</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.email_missing_payment_information" href="#api.doc_methods.payroll_entry.email_missing_payment_information">email_missing_payment_information</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.export_cash_payroll" href="#api.doc_methods.payroll_entry.export_cash_payroll">export_cash_payroll</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.export_nbk" href="#api.doc_methods.payroll_entry.export_nbk">export_nbk</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.export_payroll" href="#api.doc_methods.payroll_entry.export_payroll">export_payroll</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.fill_employee_details" href="#api.doc_methods.payroll_entry.fill_employee_details">fill_employee_details</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.get_basic_salary" href="#api.doc_methods.payroll_entry.get_basic_salary">get_basic_salary</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.get_count_employee_attendance" href="#api.doc_methods.payroll_entry.get_count_employee_attendance">get_count_employee_attendance</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.get_count_holidays_of_employee" href="#api.doc_methods.payroll_entry.get_count_holidays_of_employee">get_count_holidays_of_employee</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.get_emp_list" href="#api.doc_methods.payroll_entry.get_emp_list">get_emp_list</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.get_employee_list" href="#api.doc_methods.payroll_entry.get_employee_list">get_employee_list</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.get_existing_salary_slips" href="#api.doc_methods.payroll_entry.get_existing_salary_slips">get_existing_salary_slips</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.get_payroll_start_end_date_by_start_day" href="#api.doc_methods.payroll_entry.get_payroll_start_end_date_by_start_day">get_payroll_start_end_date_by_start_day</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.log_payroll_failure" href="#api.doc_methods.payroll_entry.log_payroll_failure">log_payroll_failure</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.seperate_salary_slip" href="#api.doc_methods.payroll_entry.seperate_salary_slip">seperate_salary_slip</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.set_bank_details" href="#api.doc_methods.payroll_entry.set_bank_details">set_bank_details</a></code></li>
<li><code><a title="api.doc_methods.payroll_entry.validate_employee_attendance" href="#api.doc_methods.payroll_entry.validate_employee_attendance">validate_employee_attendance</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>